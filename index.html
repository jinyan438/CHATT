<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šè¯é¢˜AIå¯¹è¯åº”ç”¨ (é›†æˆè§’è‰²å¡ä¸ä¸–ç•Œä¹¦)</title>
<!-- Lightweight first-paint CSS to ensure instant visible shell -->
<style>
  /* First paint: avoid FOIT and scrollbars flicker */
  html{font-display:optional}
  body{visibility:visible}
</style>

    <!-- Prism.js for syntax highlighting (CDN) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <!-- Cropper.js for image cropping (CDN) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css" rel="stylesheet">
    <style>


.greeting-switch-btn {
    position: absolute;
    bottom: 8px;
    right: 8px;
    background: rgba(0, 0, 0, 0.1);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 0.9em;
    opacity: 0.6;
    transition: opacity 0.2s, background 0.2s;
    z-index: 5;
}

.greeting-switch-btn:hover {
    opacity: 1;
    background: rgba(7, 193, 96, 0.15);
}

.message .content {
    position: relative; /* ç¡®ä¿æŒ‰é’®å®šä½æ­£ç¡® */
}


        :root {
            /* Light Theme (Default) */
            --bg-color: #f5f5f5;
            --text-color: #000000;
            --primary-color: #07c160;
            --secondary-color: #576b95;
            --border-color: #e0e0e0;
            --panel-bg: #f5f5f5;
            --input-bg: #ffffff;
            --user-msg-bg: #95ec69;
            --ai-msg-bg: #ffffff;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-track: var(--panel-bg);
            --code-bg: #f0f0f0;
            --text-color-muted: #888888;
            /* Modal variables for theming */
            --modal-bg: #ffffff;
            --modal-text-color: #000000;
            --modal-header-color: var(--primary-color);
            --modal-border-color: #e0e0e0;
            --modal-input-bg: #f0f0f0;
            --modal-btn-primary-bg: var(--primary-color);
            --modal-btn-primary-text: #ffffff;
            --modal-btn-secondary-bg: #e0e0e0;
            --modal-btn-secondary-text: #000000;

            /* START: Custom Style Variables */
            --message-font-size: 1em; /* Default to 1em of body font */
            --message-text-color: #000000; /* Default message text color */
            --italic-color: inherit;
            --italic-font-size-ratio: 1;
            --blockquote-color: var(--text-color-muted);
            --blockquote-bg-color: var(--modal-input-bg);
            --blockquote-border-color: var(--primary-color);
            --blockquote-font-size-ratio: 1;
            /* END: Custom Style Variables */
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 16px; /* This is the base UI font size, we won't change this directly anymore */
            overflow: hidden;
        }

        /* --- Main Layout --- */
        #app-container {
            display: flex;
            height: 100vh;
        }

        #sidebar {
            width: 260px;
            background-color: #ededed;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            transition: transform 0.3s ease-in-out;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            flex-grow: 1;
            width: calc(100% - 260px);
        }

        /* --- Sidebar --- */
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        #new-chat-button {
            width: 100%;
            padding: 12px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            text-align: center;
        }
        #new-chat-button:hover {
            background-color: #f0f0f0;
        }
        #global-search-input {
            width: 100%;
            box-sizing: border-box;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
        }
        #conversation-list {
            list-style: none;
            padding: 10px;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        .conversation-item {
            position: relative;
            padding: 12px 15px;
            padding-right: 35px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: background-color 0.2s ease-in-out;
        }
        .search-result-item {
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
        }
        .search-result-item:hover {
            background-color: #e0e0e0;
        }
        .result-conv-title {
            font-weight: bold;
            font-size: 0.9em;
            color: var(--primary-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }
        .result-msg-snippet {
            font-size: 0.85em;
            color: var(--text-color-muted);
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .result-msg-snippet mark {
            background-color: #ffd700;
            color: black;
            padding: 0;
            border-radius: 2px;
        }
        .conversation-item:hover {
            background-color: #e0e0e0;
        }
        .conversation-item.active {
            background-color: var(--primary-color);
            color: #ffffff;
            font-weight: bold;
        }
        .delete-conversation-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1.1em;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .conversation-item:hover .delete-conversation-btn {
            opacity: 0.7;
        }
        .delete-conversation-btn:hover {
            opacity: 1;
            color: #e06c75; /* Red */
        }
        .conversation-item.active .delete-conversation-btn {
            color: #ffffff;
        }

        /* --- Header --- */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            background-color: #ededed;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative; /* For dropdown positioning */
        }
        header .controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        header select, header button, header input {
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            outline: none;
        }
        header button:hover {
            background-color: #f0f0f0;
        }
        #chat-search-input {
            width: 120px;
            transition: width 0.3s ease-in-out;
            cursor: text;
        }
        #chat-search-input:focus {
            width: 180px;
        }

        .app-title {
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-grow: 1;
            justify-content: center;
            text-align: center;
            overflow: hidden;
            white-space: nowrap;
        }
        
        #header-app-name {
            display: block; /* Visible on desktop */
        }
        #header-conversation-title {
            display: none; /* Hidden on desktop */
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }
        #token-count-display {
            font-size: 0.8em;
            font-weight: normal;
            color: var(--text-color-muted);
            background-color: #e0e0e0;
            padding: 2px 8px;
            border-radius: 10px;
        }
        
        /* --- Chat Area --- */
        #chat-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-x: hidden;
        }
        .message {
            display: flex;
            max-width: 90%;
            align-self: flex-start;
            position: relative;
            align-items: flex-start;
        }
        /* START: NEW STYLE for expanded HTML messages */
        .message.message-render-expand {
            max-width: calc(100% - 40px); /* Allow bubble to grow, with some padding */
            align-self: flex-start !important; /* Force left-alignment for expanded bubbles to prevent layout shifts */
        }
        .message.user.message-render-expand {
            align-self: flex-end !important; /* Re-apply for user messages */
        }
        .render-container {
            overflow: hidden;
            position: relative;
            margin-top: 10px;
        }
        /* END: NEW STYLE */

        .message:hover .message-controls {
            opacity: 1;
        }
        .message.user {
            align-self: flex-end;
        }
        .message .avatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background-color: var(--input-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
            overflow: hidden;
        }
        .message .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .message.user .avatar {
            margin-right: 0;
            margin-left: 15px;
        }
        /* START: MODIFIED .message .content */
        .message .content {
            padding: 0.1px 10px;
            line-height: 1.5;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            font-size: var(--message-font-size);
            color: var(--message-text-color);
        }
        /* END: MODIFIED .message .content */
        .message .content mark {
            background-color: #ffd700;
            padding: 0;
        }
        .message.user .content {
            background-color: var(--user-msg-bg);
        }
        .message-header {
            font-size: 0.8em;
            color: var(--text-color-muted);
            margin-bottom: 4px;
            padding: 0 2px;
        }
        .message.user .message-header {
            text-align: right;
        }
        #chat-container.hide-nicknames .message-header {
            display: none;
        }

        .message-controls {
            position: absolute;
            bottom: -12px; 
            right: 15px; 
            background: #e0e0e0;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 1px 6px; 
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .message.user .message-controls {
            right: auto;
            left: 15px; 
        }
        .message-controls button {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9em;
        }
        .message-controls button:hover { color: var(--primary-color); }
        .editing-textarea {
            width: 100%;
            box-sizing: border-box;
            min-height: 100px;
            background-color: var(--input-bg);
            border: 1px solid var(--primary-color);
            color: var(--text-color);
            border-radius: 6px;
            padding: 10px;
            font-size: 1em;
            font-family: inherit;
        }
        .edit-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .edit-controls button {
            padding: 5px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }
        .edit-controls .save { background-color: var(--primary-color); color: #ffffff; }
        .edit-controls .cancel { background-color: #e0e0e0; color: var(--text-color); }

        /* --- Input Area --- */
        #input-area {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            background-color: #ededed;
            flex-shrink: 0;
        }
        .input-wrapper {
            display: flex;
            align-items: center;
            background-color: var(--input-bg);
            border-radius: 8px;
            padding: 10px;
        }
        #message-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 1em;
            resize: none;
            outline: none;
            max-height: 200px;
        }
        #send-button, #upload-button {
            background: none;
            border: none;
            color: #555;
            cursor: pointer;
            padding: 5px 10px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        #send-button:hover { color: var(--primary-color); }
        
        .stop-loader-wrapper {
            position: relative; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
        }
        .stop-loader {
            width: 24px; height: 24px; border: 2px solid var(--primary-color); border-top-color: transparent; border-right-color: transparent;
            border-radius: 50%; animation: rotation 0.8s linear infinite;
        }
        .stop-square {
            position: absolute; width: 8px; height: 8px; background-color: var(--primary-color);
        }

        #input-options {
            display: flex; gap: 20px; margin-top: 10px; align-items: center; font-size: 0.9em;
        }
        #input-options label {
            display: flex; align-items: center; gap: 5px; cursor: pointer;
        }
        .loader {
            width: 18px; height: 18px; border: 2px solid var(--primary-color); border-bottom-color: transparent; border-radius: 50%;
            display: inline-block; box-sizing: border-box; animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .typing-cursor {
            display: inline-block; width: 8px; height: 1.2em; background-color: var(--primary-color); animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            from, to { background-color: transparent; }
            50% { background-color: var(--primary-color); }
        }

        .message .content > :first-child {
            margin-top: 0;
        }
        .message .content > :last-child {
            margin-bottom: 0;
        }

        .message .content {
            padding: 8px 10px;
            line-height: 1.5;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
        }

        /* START: NEW Custom Text Element Styles */
        .message .content em {
            color: var(--italic-color);
            font-size: calc(1em * var(--italic-font-size-ratio));
        }
        .message .content blockquote {
            color: var(--blockquote-color);
            background-color: var(--blockquote-bg-color);
            border-left: 4px solid var(--blockquote-border-color);
            font-size: calc(1em * var(--blockquote-font-size-ratio));
            margin: 1em 0;
            padding: 0.5em 1em;
            border-radius: 4px;
        }
        .message .content blockquote p:first-child {
            margin-top: 0;
        }
        .message .content blockquote p:last-child {
            margin-bottom: 0;
        }
        /* END: NEW Custom Text Element Styles */

        /* Code Blocks Style (Forced Dark) */
        .message .content pre {
            background-color: #282c34;
            border: 1px solid #3b4048;
            border-radius: 8px;
            position: relative;
            font-size: 0.9em;
            transition: max-height 0.3s ease-in-out;
            margin: 0.5em 0;
            padding: 0;
            white-space: pre;
        }
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #21252b;
            color: #abb2bf;
            padding: 8px 15px;
            border-bottom: 1px solid #3b4048;
            font-size: 0.85em;
        }
        .code-header .lang {
            font-weight: bold;
            color: #61afef;
        }
        .code-header .code-buttons { display: flex; gap: 15px; }
        .code-header button {
            background: none;
            border: none;
            color: #abb2bf;
            cursor: pointer;
            font-size: 1.1em;
            padding: 0;
            opacity: 0.7;
            transition: opacity 0.2s, color 0.2s;
        }
        .code-header button:hover {
            opacity: 1;
            color: #61afef;
        }
        .message .content pre > code {
            color: #abb2bf;
            padding: 12px 15px;
            display: block;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        pre.collapsed { max-height: 42px !important; overflow: hidden; }
        pre.collapsed > code { display: none; }
        
        /* --- Attachments --- */
        .attachment-preview { display: inline-block; position: relative; margin: 10px 10px 0 0; }
        .attachment-preview img { max-width: 100px; max-height: 100px; border-radius: 6px; border: 1px solid var(--border-color); }
        .attachment-preview .remove-attachment {
            position: absolute; top: -5px; right: -5px; background: #ff5555; color: white; border-radius: 50%;
            width: 20px; height: 20px; border: none; cursor: pointer; font-weight: bold; display: flex;
            align-items: center; justify-content: center; line-height: 1;
        }
        .message-attachment-container { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
        .message-attachment {
            display: inline-flex; align-items: center; background-color: #e0e0e0; padding: 8px 12px;
            border-radius: 6px; gap: 8px;
        }
        .message-attachment span:first-child { font-size: 1.2em; }

        /* --- Settings & Cropper Modal --- */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--modal-bg); color: var(--modal-text-color);
            margin: auto; padding: 30px; border: 1px solid var(--modal-border-color); width: 80%;
            max-width: 800px; border-radius: 10px; display: flex; flex-direction: column; gap: 20px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.3);
            max-height: 90vh;
        }
        .modal-body {
             overflow-y: auto;
             padding-right: 15px; /* space for scrollbar */
        }
        .modal-content h2 { margin-top: 0; color: var(--modal-header-color); }
        .modal-content .form-group { display: flex; flex-direction: column; gap: 8px; }
        .modal-content label { font-weight: bold; }
        .modal-content input, .modal-content textarea, .modal-content select {
            width: 100%; padding: 10px; background-color: var(--modal-input-bg); border: 1px solid var(--modal-border-color);
            border-radius: 6px; color: var(--modal-text-color); box-sizing: border-box; font-family: inherit;
        }
         .modal-content textarea {
            resize: vertical;
        }
        .modal-content .modal-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px; flex-shrink: 0;}
        .modal-content button { padding: 10px 20px; border-radius: 6px; border: none; cursor: pointer; }
        .modal-content .btn-primary { background-color: var(--modal-btn-primary-bg); color: var(--modal-btn-primary-text); }
        .modal-content .btn-secondary { background-color: var(--modal-btn-secondary-bg); color: var(--modal-btn-secondary-text); }
        .modal-content .provider-item { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; }
        .modal-content hr { border-color: var(--modal-border-color); width: 100%; }
        .modal-content .avatar-setting { display: flex; align-items: center; gap: 15px; }
        .modal-content .avatar-preview { width: 50px; height: 50px; border-radius: 8px; background-color: var(--modal-input-bg); cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold; overflow: hidden; }
        .modal-content .avatar-preview img { width: 100%; height: 100%; object-fit: cover; }
        .modal-content .model-profile-item { display: flex; align-items: center; gap: 15px; margin-bottom: 15px; }

        .settings-tabs, .editor-tabs {
            display: flex;
            border-bottom: 1px solid var(--modal-border-color);
            margin-bottom: 15px;
            flex-shrink: 0;
        }
        .tab-button {
            padding: 10px 15px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: var(--text-color-muted);
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            color: var(--modal-header-color);
            border-bottom-color: var(--modal-header-color);
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        #system-prompt-templates-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        #system-prompt-templates-container button {
            padding: 5px 10px;
            font-size: 0.85em;
            background-color: var(--modal-btn-secondary-bg);
            color: var(--modal-btn-secondary-text);
            border: 1px solid var(--modal-border-color);
            border-radius: 5px;
            cursor: pointer;
        }
        #system-prompt-templates-container button:hover {
            border-color: var(--primary-color);
        }

        /* --- Scrollbar --- */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }

        /* --- Misc --- */
        .hidden { display: none !important; }
        p.stopped-message { color: var(--text-color-muted); font-style: italic; margin-top: 10px; }
        .save-feedback {
            color: var(--primary-color);
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        /* --- WeChat Style Enhancements (Final Version) --- */
        .message.user .content {
            background-color: #95ec69; 
            /* Let the color inherit from .message .content */
        }
        .message:not(.user) .content {
            background-color: #ffffff;
             /* Let the color inherit from .message .content */
            border: 1px solid var(--border-color);
        }

        .message .content {
            position: relative;
            border-radius: 8px;
        }

        /* --- Status Block Renderer --- */
        .status-block-shell {
            margin-top: 15px;
            border-radius: 18px;
            padding: 18px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(49, 46, 129, 0.85));
            border: 1px solid rgba(148, 163, 184, 0.35);
            color: #f8fafc;
            box-shadow: 0 12px 35px rgba(2, 6, 23, 0.45);
        }
        .status-block-header {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin-bottom: 12px;
        }
        .status-pill {
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            padding: 12px;
            background: rgba(15, 23, 42, 0.5);
        }
        .status-pill span {
            display: block;
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(248, 250, 252, 0.75);
            margin-bottom: 4px;
        }
        .status-pill strong {
            font-size: 1.05em;
            color: #fff;
            word-break: break-word;
        }
        .status-block-section {
            margin-top: 16px;
        }
        .status-block-section h3 {
            margin: 0 0 8px;
            font-size: 1em;
            letter-spacing: 0.05em;
            color: #f8fafc;
        }
        .status-block-maintext {
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.45);
            padding: 12px;
            font-size: 0.95em;
            line-height: 1.6;
        }
        .status-block-maintext p {
            margin: 0 0 0.8em;
        }
        .status-block-maintext p:last-child {
            margin-bottom: 0;
        }
        .status-character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .status-character-card {
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(255, 255, 255, 0.04);
            padding: 12px;
        }
        .status-character-card h4 {
            margin: 0 0 8px;
            font-size: 1em;
            color: #fff;
        }
        .status-character-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .status-character-card li {
            margin-bottom: 8px;
        }
        .status-character-card li:last-child {
            margin-bottom: 0;
        }
        .status-character-card li span {
            display: block;
            font-size: 0.8em;
            letter-spacing: 0.08em;
            color: rgba(248, 250, 252, 0.75);
            margin-bottom: 2px;
        }
        .status-character-card li p {
            margin: 0;
            color: #e2e8f0;
            font-size: 0.9em;
        }
        .status-actions {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .status-actions li {
            border-left: 3px solid rgba(248, 250, 252, 0.45);
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            font-size: 0.95em;
            color: #f8fafc;
        }
        .status-empty {
            color: rgba(248, 250, 252, 0.75);
            font-size: 0.9em;
        }
        .status-block-error {
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(248, 113, 113, 0.45);
            background: rgba(248, 113, 113, 0.15);
            color: #fecaca;
            font-size: 0.9em;
        }
        
        /* Tables from Markdown */
        .message .content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: 100%;
            border: 1px solid var(--border-color);
        }
        .message .content th, .message .content td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
        }
        .message .content th {
            background-color: var(--panel-bg);
            font-weight: bold;
        }

        .message:not(.user) .content::before {
            content: '';
            position: absolute;
            top: 10px;
            left: -10px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-right: 10px solid #ffffff;
        }

        .message.user .content::before {
            content: '';
            position: absolute;
            top: 10px;
            right: -10px;
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            border-left: 10px solid #95ec69;
        }

        .message:not(.user) .content {
            border-top-left-radius: 4px;
        }
        .message.user .content {
            border-top-right-radius: 4px;
        }
        
        /* --- START: Mobile Mode Styles --- */
        #menu-toggle-button {
            display: none;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-color);
            padding: 0 10px 0 0;
        }

        #sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
            z-index: 998;
        }
        
        #mobile-actions-menu {
            display: none;
            position: absolute;
            top: calc(100% + 5px);
            right: 10px;
            background-color: var(--modal-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            width: 220px;
            padding: 8px;
        }
        #mobile-actions-menu.visible {
            display: block;
        }
        .mobile-action-item {
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 6px;
        }
        .mobile-action-item label {
            font-size: 0.8em;
            font-weight: bold;
            color: var(--text-color-muted);
        }
        .mobile-action-item select, .mobile-action-item input, .mobile-action-item button {
            width: 100%;
            box-sizing: border-box;
        }
        .mobile-action-item hr {
            width: 100%;
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 6px 0;
        }
        /* --- END: Mobile Mode Styles --- */

        /* --- START: Character Card Selection & Editor Styles --- */
        #character-selection-modal .modal-content {
            max-width: 95%;
            width: 1200px;
        }

        .character-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 20px;
            padding: 10px;
            overflow-y: auto;
        }

        .character-card, .import-card-placeholder {
            position: relative;
            aspect-ratio: 3 / 4;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            background-color: var(--input-bg);
        }
        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }

        .character-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .character-card-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white;
            font-weight: bold;
            text-align: center;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .character-card-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 6px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .character-card:hover .character-card-actions {
            opacity: 1;
        }
        .character-card-actions button {
            background-color: rgba(0,0,0,0.6);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        .character-card-actions button:hover {
            background-color: rgba(0,0,0,0.8);
        }

        .import-card-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--border-color);
            color: var(--text-color-muted);
        }
        .import-card-placeholder:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        .import-card-placeholder .plus-icon {
            font-size: 3em;
            font-weight: 200;
        }

        #character-editor-modal .modal-content, #global-world-book-editor-modal .modal-content {
            max-width: 90%;
            width: 1000px;
        }
        .editor-form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .form-group-full-width {
            grid-column: 1 / -1;
        }

        .world-book-entry {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
        }
        .world-book-entry .form-group {
            margin-bottom: 10px;
        }
        .world-book-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .world-book-header h4 {
            margin: 0;
        }

        .toggle-switch-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            font-size: 0.9em;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        .toggle-switch input {
            cursor: pointer;
        }
        
        .alternate-greeting-item {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            margin-bottom: 10px;
        }
        .alternate-greeting-item textarea {
            flex-grow: 1;
            min-height: 50px;
        }
        .alternate-greeting-item button {
            padding: 8px;
            line-height: 1;
        }

        /* --- END: Character Card Styles --- */

        /* START: New Preset Editor Styles */
        .prompt-item {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 10px;
            padding: 15px;
            background-color: var(--modal-input-bg);
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }
        .prompt-item-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .prompt-item-content {
            flex-grow: 1;
        }
        .prompt-item-handle {
            cursor: grab;
            padding: 5px;
            font-size: 1.2em;
            color: var(--text-color-muted);
        }
        .prompt-item-content input[type="text"] {
            margin-bottom: 10px;
        }
        .prompt-item textarea {
            min-height: 80px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .prompt-item-advanced {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        .prompt-item-advanced .form-group {
            gap: 4px;
        }
        .prompt-item-advanced label {
            font-size: 0.8em;
            font-weight: normal;
            color: var(--text-color-muted);
        }
         .prompt-item-advanced input, .prompt-item-advanced select {
            padding: 6px;
            font-size: 0.9em;
        }

        #preset-editor-modal .modal-content {
            max-width: 95%;
            width: 1200px;
        }
        .regex-item {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            background-color: var(--modal-input-bg);
        }
        .regex-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
/* æ–‡æœ¬åŸŸæ»šåŠ¨ & è‡ªåŠ¨æ¢è¡Œï¼Œé¿å…æº¢å‡º */
.regex-item textarea {
  max-height: 280px;
  overflow: auto;
  white-space: pre-wrap;
  word-break: break-word;
}
/* ä»£ç å—é•¿è¡Œæ¢è¡Œï¼Œé¿å…æ¨ªå‘æ’‘ç ´ */
.message .content pre > code {
  white-space: pre-wrap;  /* è¿™æ¡ä½ é¡µé¢é‡Œå·²å¯ç”¨ï¼Œä¿æŒå³å¯ */
  word-break: break-word; /* å·²å¯ç”¨ï¼Œä¿æŒå³å¯ */
}
        /* END: New Preset Editor Styles */


        /* --- START: Media Query for Mobile Devices --- */
        @media (max-width: 768px) {
            #app {
                width: 100%;
            }
        
            #menu-toggle-button {
                display: block;
                position: absolute;
                left: 10px;
                top: 50%;
                transform: translateY(-50%);
                z-index: 2;
            }

            #sidebar {
                position: fixed;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 999;
                transform: translateX(-100%);
                border-right: 1px solid var(--border-color);
            }

            #app-container.sidebar-visible #sidebar {
                transform: translateX(0);
                box-shadow: 2px 0 15px rgba(0,0,0,0.15);
            }
            
            #app-container.sidebar-visible #sidebar-overlay {
                display: block;
            }
            
            header {
                padding: 8px 10px;
                justify-content: space-between;
            }

            .app-title {
                padding: 0 40px;
                font-size: 1.1em;
            }

            #header-app-name, #token-count-display {
                display: none;
            }
            #header-conversation-title {
                display: block;
            }

            header .controls {
                display: none;
            }
            
            #settings-button-mobile-trigger {
                display: flex !important;
                align-items: center;
                justify-content: center;
                position: absolute;
                right: 10px;
                top: 50%;
                transform: translateY(-50%);
                z-index: 2;
                padding: 8px;
                font-size: 1.2em;
            }

            #input-area {
                padding: 8px 12px;
            }
            .input-wrapper {
                padding: 5px 10px;
            }
            #input-options {
                margin-top: 6px;
                gap: 15px;
                font-size: 0.8em;
            }
            .character-gallery {
                 grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                 gap: 15px;
            }
             #character-editor-modal .editor-form-grid, #global-world-book-editor-modal .editor-form-grid {
                grid-template-columns: 1fr;
            }
            #preset-editor-modal .editor-form-grid {
                grid-template-columns: 1fr;
            }
             .prompt-item-advanced {
                grid-template-columns: 1fr 1fr;
            }
        }
        /* --- END: Media Query --- */

    
/* === MOBILE COMPACT TWEAKS (added by ChatGPT) === */
@media (max-width: 768px) {
  /* Tighten paddings to free vertical space */
  header{ padding:4px 8px !important; }
  .app-title{ padding:0 32px !important; font-size:1em !important; }
  #chat-container{ padding:12px 8px !important; gap:12px !important; }

  /* Make bubbles full-width-ish */
  .message{ max-width:100% !important; }
  .message.message-render-expand{ max-width:100% !important; }
  .message .content{ padding:10px 12px !important; }
  
  /* Smaller avatars for more content width */
  .message .avatar{ width:28px !important; height:28px !important; margin-right:8px !important; }
  .message.user .avatar{ margin-left:8px !important; }
  
  /* Make code blocks more space-efficient on mobile */
  .message .content pre{ font-size:0.85em !important; }
  .code-header{ padding:6px 10px !important; font-size:0.8em !important; }
  .message .content pre > code{ padding:10px 12px !important; }

  /* Input area compaction */
  #input-area{ padding:6px 8px !important; }
  .input-wrapper{ padding:6px 8px !important; }
  #message-input{ max-height:40vh !important; }
  #input-options{ margin-top:4px !important; gap:12px !important; font-size:0.8em !important; }

  /* Mobile actions menu: a bit narrower to feel lighter */
  #mobile-actions-menu{ width:200px !important; }

  /* Slightly reduce message font size on very small screens while preserving readability */
  :root{ --message-font-size: 15px; }
}
/* === END MOBILE COMPACT TWEAKS === */

/* === MOBILE INPUT BAR EXTRA COMPRESSION (v2) === */
@media (max-width: 768px) {
  /* Overall input area */
  #input-area{ padding:4px 6px !important; border-top-width:1px !important; }
  .input-wrapper{ padding:4px 6px !important; border-radius:10px !important; }

  /* Textarea / input */
  #message-input{
    min-height:34px !important;
    max-height:36vh !important;
    line-height:1.2 !important;
    padding:8px 10px !important;
    font-size:0.95em !important;
  }
  #message-input::placeholder{ font-size:0.9em !important; }

  /* Buttons/icons near the input: attach / send / settings etc. */
  #input-area .send-btn,
  #input-area .attach-btn,
  #input-area .action-btn,
  #input-area .icon-btn{
    width:32px !important; height:32px !important;
    min-width:32px !important; min-height:32px !important;
  }
  #input-area .send-btn svg,
  #input-area .attach-btn svg,
  #input-area .action-btn svg,
  #input-area .icon-btn svg{
    width:18px !important; height:18px !important;
  }

  /* The options row under the input (checkboxes like â€œæµå¼è¾“å‡º/è”ç½‘æœç´¢â€) */
  #input-options{
    margin-top:2px !important;
    padding:0 !important;
    gap:8px !important;
    font-size:0.75em !important;
    line-height:1.1 !important;
  }
  #input-options label{ margin-right:6px !important; }
  #input-options input[type="checkbox"]{ transform:scale(0.9); }

  /* Reduce bottom padding to let content areaæ›´å¤§ */
  #chat-container{ padding-bottom:8px !important; }

  /* Safe area for full-screen phones */
  body{ padding-bottom: env(safe-area-inset-bottom); }
}
/* === END v2 === */

/* === MOBILE INPUT BAR EXTRA COMPRESSION (v3 - stronger specificity) === */
@media (max-width: 1024px) {
  /* Use higher specificity to beat previous rules */
  body #input-area,
  .app-container #input-area,
  #app #input-area {
    padding: 2px 6px !important;
    border-top-width: 1px !important;
  }
  body #input-area .input-wrapper,
  .app-container #input-area .input-wrapper,
  #app #input-area .input-wrapper {
    padding: 4px 6px !important;
    border-radius: 10px !important;
  }
  body #input-area #message-input,
  .app-container #input-area #message-input,
  #app #input-area #message-input {
    min-height: 32px !important;
    max-height: 32vh !important;
    line-height: 1.2 !important;
    padding: 6px 8px !important;
    font-size: 0.95em !important;
  }
  body #input-area #send-button,
  body #input-area #upload-button {
    width: 28px !important; height: 28px !important;
    min-width: 28px !important; min-height: 28px !important;
    padding: 0 !important; margin: 0 2px !important;
  }
  body #input-area #send-button svg,
  body #input-area #upload-button svg {
    width: 16px !important; height: 16px !important;
  }
  body #input-options,
  .app-container #input-options {
    margin-top: 0 !important;
    padding: 0 !important;
    gap: 6px !important;
    font-size: 0.72em !important;
    line-height: 1.05 !important;
  }
  body #chat-container { padding-bottom: 6px !important; }
}
/* === END v3 === */

/* === INPUT BAR MINIMAL HEIGHT (v4 - global force) === */
/* No media query: always apply, with very strong selectors */
body #input-area{
  padding: 4px 6px !important;
  border-top-width:1px !important;
}
body #input-area .input-wrapper{
  display:flex !important;
  align-items:center !important;
  gap:6px !important;
  padding: 4px 6px !important;
  height: 44px !important;         /* <= hard cap the total height */
  border-radius:10px !important;
}
/* Make the textarea fit into the 44px wrapper */
body #input-area #message-input{
  height: 32px !important;          /* text line area */
  min-height: 32px !important;
  max-height: 32px !important;
  line-height: 1.2 !important;
  padding: 6px 8px !important;
  font-size: 0.95em !important;
  box-sizing: border-box !important;
}
/* Shrink the buttons so they don't force the wrapper taller */
body #input-area #send-button,
body #input-area #upload-button{
  width: 28px !important;
  height: 28px !important;
  min-width:28px !important;
  min-height:28px !important;
  padding:0 !important;
  margin:0 2px !important;
  font-size: 1em !important;        /* override 1.5em */
  line-height: 28px !important;
  display:flex !important;
  align-items:center !important;
  justify-content:center !important;
}
body #input-area #send-button svg,
body #input-area #upload-button svg{
  width:16px !important; height:16px !important;
}
/* Options row under the bar: ultra compact */
body #input-options{
  margin-top: 2px !important;
  gap:8px !important;
  font-size: 0.75em !important;
  line-height: 1.1 !important;
  padding:0 !important;
}
/* Reduce bottom padding in chat area to reclaim space */
body #chat-container{ padding-bottom: 6px !important; }
</style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <div class="sidebar-header">
                <button id="new-chat-button">+ æ–°å»ºè¯é¢˜</button>
                <!-- START: MODIFIED Character Card Button -->
                <button id="open-character-gallery-button" style="width: 100%; margin-top: 10px; padding: 12px; background-color: #576b95; color: white; border: none; border-radius: 6px; font-size: 1em; cursor: pointer;">
                    ğŸ‘¤ è§’è‰²é€‰æ‹©
                </button>
                <input type="file" id="character-card-input" accept="image/png" class="hidden">
                <!-- END: MODIFIED Character Card Button -->
                <input type="search" id="global-search-input" placeholder="å…¨å±€æœç´¢...">
            </div>
            <ul id="conversation-list"></ul>
        </div>

        <div id="app">
            <header>
                <button id="menu-toggle-button">â˜°</button>
                <div class="app-title">
                    <span id="header-app-name">å¤šè¯é¢˜AIå¯¹è¯åº”ç”¨</span>
                    <span id="header-conversation-title"></span>
                    <span id="token-count-display"></span>
                </div>
                <div class="controls">
                    <input type="search" id="chat-search-input" placeholder="æœç´¢...">
                    <select id="provider-selector"></select>
                    <select id="model-selector"></select>
                    <!-- NEW: Global Preset Selector -->
                    <select id="preset-selector"></select>
                    <button id="export-chat-button" title="å¯¼å‡ºå½“å‰è¯é¢˜">â¬‡ï¸</button>
                    <!-- MODIFIED: Preset Button -->
                    <button id="preset-button" title="ç®¡ç†å…¨å±€é¢„è®¾">âš™ï¸ é¢„è®¾</button>
                    <button id="settings-button">âš™ï¸ è®¾ç½®</button>
                </div>
                <!-- START: Mobile Header Controls -->
                <button id="settings-button-mobile-trigger" class="hidden">âš™ï¸</button>
                <div id="mobile-actions-menu">
                    <div class="mobile-action-item">
                        <label for="provider-selector-mobile">ä¾›åº”å•†</label>
                        <select id="provider-selector-mobile"></select>
                    </div>
                    <div class="mobile-action-item">
                        <label for="model-selector-mobile">æ¨¡å‹</label>
                        <select id="model-selector-mobile"></select>
                    </div>
                    <div class="mobile-action-item">
                        <label for="preset-selector-mobile">å…¨å±€é¢„è®¾</label>
                        <select id="preset-selector-mobile"></select>
                    </div>
                     <div class="mobile-action-item">
                         <hr>
                         <input type="search" id="chat-search-input-mobile" placeholder="åœ¨è¯é¢˜å†…æœç´¢...">
                    </div>
                     <div class="mobile-action-item">
                         <button id="export-chat-button-mobile">â¬‡ï¸ å¯¼å‡ºå½“å‰è¯é¢˜</button>
                    </div>
                    <div class="mobile-action-item">
                        <hr>
                        <button id="open-preset-editor-button">âš™ï¸ ç®¡ç†å…¨å±€é¢„è®¾</button>
                    </div>
                    <div class="mobile-action-item">
                        <button id="open-full-settings-button">âš™ï¸ æ‰“å¼€å®Œæ•´è®¾ç½®</button>
                    </div>
                </div>
                <!-- END: Mobile Header Controls -->
            </header>

            <div id="chat-container"></div>

            <div id="input-area">
                <div id="attachment-previews"></div>
                <div class="input-wrapper">
                    <textarea id="message-input" rows="1" placeholder="è¾“å…¥æ¶ˆæ¯... (â†‘ ç¼–è¾‘ä¸Šä¸€æ¡)"></textarea>
                    <input type="file" id="file-input" hidden multiple>
                    <button id="upload-button" title="ä¸Šä¼ é™„ä»¶">ğŸ“</button>
                    <button id="send-button" title="å‘é€ (Cmd/Ctrl+Enter)">â¤</button>
                </div>
                <div id="input-options">
                    <label><input type="checkbox" id="stream-toggle" checked> æµå¼è¾“å‡º</label>
                    <label><input type="checkbox" id="search-toggle"> è”ç½‘æœç´¢</label>
                </div>
            </div>
        </div>
    </div>

    <!-- START: Sidebar Overlay for Mobile -->
    <div id="sidebar-overlay"></div>
    <!-- END: Sidebar Overlay -->

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <h2>è®¾ç½®</h2>
            
            <div class="settings-tabs">
                <button class="tab-button active" data-tab="profile-tab">ä¸ªäººèµ„æ–™ä¸å¤´åƒ</button>
                <button class="tab-button" data-tab="providers-tab">AI ä¾›åº”å•†</button>
                <button class="tab-button" data-tab="model-params-tab">æ¨¡å‹å‚æ•°</button>
                <button class="tab-button" data-tab="world-books-tab">å…¨å±€ä¸–ç•Œä¹¦</button>
                <button class="tab-button" data-tab="appearance-tab">å¤–è§‚</button>
                <button class="tab-button" data-tab="data-tab">æ•°æ®ç®¡ç†</button>
            </div>

            <div class="modal-body">
                <!-- Profile & Avatars Tab -->
                <div id="profile-tab" class="tab-content active">
                    <h3>ç”¨æˆ·è®¾ç½®</h3>
                    <div class="form-group">
                        <label for="user-name">ç”¨æˆ·å</label>
                        <input type="text" id="user-name" placeholder="ä½ çš„æ˜µç§°">
                    </div>
                    <div class="form-group">
                        <label for="user-description">ç”¨æˆ·è®¾å®š</label>
                        <textarea id="user-description" rows="3" placeholder="å…³äºä½ è‡ªå·±çš„æè¿°ï¼ŒAIåœ¨å¯¹è¯æ—¶ä¼šå‚è€ƒæ­¤è®¾å®šã€‚"></textarea>
                    </div>
                    <div class="form-group">
                        <label>ç”¨æˆ·å¤´åƒ</label>
                        <div class="avatar-setting">
                            <div id="user-avatar-preview" class="avatar-preview" onclick="document.getElementById('user-avatar-input').click()"></div>
                            <input type="file" id="user-avatar-input" accept="image/*" class="hidden">
                            <button id="save-user-profile" class="btn-secondary">ä¿å­˜ç”¨æˆ·è®¾ç½®</button>
                        </div>
                    </div>
                    <hr>
                    <h3>æ¨¡å‹è®¾ç½®</h3>
                    <div id="model-profile-list"></div>
                </div>

                <!-- AI Providers Tab -->
                <div id="providers-tab" class="tab-content">
                    <h3>å½“å‰ä¾›åº”å•†</h3>
                    <div id="provider-list"></div>
                    <hr>
                    <h3>æ·»åŠ /ç¼–è¾‘ä¾›åº”å•†</h3>
                    <input type="hidden" id="provider-id">
                    <div class="form-group">
                        <label for="provider-name">åç§°</label>
                        <input type="text" id="provider-name" placeholder="ä¾‹å¦‚ï¼šMy OpenAI">
                    </div>
                    <div class="form-group">
                        <label for="api-url">API åœ°å€</label>
                        <input type="text" id="api-url" placeholder="ä¾‹å¦‚ï¼šhttps://api.openai.com/v1">
                    </div>
                    <div class="form-group">
                        <label for="api-endpoint">API ç«¯ç‚¹ (å¯é€‰)</label>
                        <input type="text" id="api-endpoint" placeholder="é»˜è®¤: /chat/completions">
                    </div>
                    <div class="form-group">
                        <label for="api-key">API å¯†é’¥</label>
                        <input type="password" id="api-key" placeholder="sk-...">
                    </div>
                    <div class="form-group">
                        <label for="model-names">æ¨¡å‹åç§° (ç”¨é€—å·,åˆ†éš”)</label>
                        <input type="text" id="model-names" placeholder="gpt-4, gpt-3.5-turbo">
                    </div>
                    <div class="modal-buttons">
                        <button id="save-provider-button" class="btn-primary">ä¿å­˜ä¾›åº”å•†</button>
                    </div>
                </div>

                <!-- Model Parameters Tab -->
                <div id="model-params-tab" class="tab-content">
                    <p class="text-muted" style="font-size: 0.9em; margin-top: 0; padding: 10px; background-color: var(--modal-input-bg); border-radius: 6px;">
                        <strong>æ³¨æ„ï¼š</strong>æ ¸å¿ƒé‡‡æ ·å‚æ•°ï¼ˆå¦‚ Temperature, Max Tokens ç­‰ï¼‰ç°å·²ç§»è‡³ <strong><a href="#" onclick="closeSettingsModal(); openPresetEditor(); return false;">å…¨å±€é¢„è®¾ç¼–è¾‘å™¨</a></strong> ä¸­è¿›è¡Œç»Ÿä¸€ç®¡ç†ã€‚
                    </p>
                    <div class="form-group">
                        <label for="context-count">ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•° (0ä¸ºä¸é™åˆ¶)</label>
                        <input type="number" id="context-count" min="0" value="10">
                    </div>
                    <div class="form-group">
                        <label for="system-prompt">ç³»ç»Ÿæç¤ºè¯ (System Prompt)</label>
                        <textarea id="system-prompt" rows="4" placeholder="ä¸ºå½“å‰è¯é¢˜è®¾å®šAIçš„è§’è‰²ã€è¯­æ°”å’Œè¡Œä¸ºæŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼šä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç¿»è¯‘å®¶ã€‚"></textarea>
                    </div>
                    <div class="form-group">
                        <label>æç¤ºè¯æ¨¡æ¿</label>
                        <div id="system-prompt-templates-container"></div>
                    </div>
                </div>

                <!-- NEW: Global World Books Tab -->
                <div id="world-books-tab" class="tab-content">
                    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3>å…¨å±€ä¸–ç•Œä¹¦ç®¡ç†</h3>
                        <div>
                            <button id="import-global-book-button" class="btn-secondary">å¯¼å…¥</button>
                            <input type="file" id="import-global-book-input" accept=".json" class="hidden">
                            <button id="add-new-global-book-button" class="btn-primary" style="margin-left: 10px;">+ æ–°å»º</button>
                        </div>
                    </div>
                    <p class="text-muted" style="font-size: 0.9em; margin-top: -10px; margin-bottom: 20px;">æ­¤å¤„å¯ç”¨çš„ä¸–ç•Œä¹¦å°†ä½œç”¨äºæ‰€æœ‰å¯¹è¯ã€‚å®ƒä»¬çš„ä¼˜å…ˆçº§ä½äºè§’è‰²è‡ªå¸¦çš„ä¸–ç•Œä¹¦ã€‚</p>
                    <div id="global-world-books-list-container">
                        <!-- Global world books will be listed here -->
                    </div>
                </div>

                <!-- Appearance Tab -->
                <div id="appearance-tab" class="tab-content">
                    <h3>ä¸»é¢˜è®¾ç½®</h3>
                    <p>åˆ‡æ¢åº”ç”¨çš„ä¸»é¢˜é¢œè‰²æ–¹æ¡ˆã€‚</p>
                    <div class="form-group">
                        <label for="theme-selector">é€‰æ‹©ä¸»é¢˜</label>
                        <select id="theme-selector"></select>
                    </div>
                    <hr style="margin: 20px 0;">

                    <!-- START: MODIFIED SECTION -->
                    <h3>è‡ªå®šä¹‰æ ·å¼</h3>
                    <p>å¾®è°ƒæ¶ˆæ¯æ°”æ³¡å†…çš„å­—ä½“å¤§å°å’Œé¢œè‰²ã€‚è¿™äº›è®¾ç½®ä¼šè¦†ç›–ä¸»é¢˜çš„é»˜è®¤å€¼ã€‚</p>
                    <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="custom-font-size">æ¶ˆæ¯å­—ä½“å¤§å° (px)</label>
                            <input type="number" id="custom-font-size" min="12" max="24" step="1">
                        </div>
                        <div class="form-group">
                            <label for="custom-text-color">æ¶ˆæ¯æ–‡æœ¬é¢œè‰²</label>
                            <input type="color" id="custom-text-color" style="padding: 2px; height: 38px;">
                        </div>
                        <div class="form-group">
                            <label for="custom-bg-color">å…¨å±€èƒŒæ™¯é¢œè‰²</label>
                            <input type="color" id="custom-bg-color" style="padding: 2px; height: 38px;">
                        </div>
                        <div class="form-group">
                            <label for="custom-primary-color">å…¨å±€ä¸»é¢˜è‰²</label>
                            <input type="color" id="custom-primary-color" style="padding: 2px; height: 38px;">
                        </div>
                    </div>
                    
                    <hr style="margin: 20px 0;">
                    <h3>æ–‡æœ¬å…ƒç´ æ ·å¼</h3>
                    <p>ä¸ºæ–œä½“å’Œå¼•ç”¨ç­‰ç‰¹å®šæ–‡æœ¬å…ƒç´ è®¾ç½®ç‹¬ç«‹çš„æ ·å¼ã€‚</p>
                    <div class="editor-form-grid">
                        <!-- Italic Styles -->
                        <div class="form-group">
                            <label for="custom-italic-color">æ–œä½“æ–‡æœ¬é¢œè‰²</label>
                            <input type="color" id="custom-italic-color" style="padding: 2px; height: 38px;">
                        </div>
                        <div class="form-group">
                            <label for="custom-italic-font-size-ratio">æ–œä½“å­—ä½“å¤§å° (å€ç‡)</label>
                            <input type="number" id="custom-italic-font-size-ratio" min="0.5" max="2" step="0.1">
                        </div>
                        <!-- Blockquote Styles -->
                        <div class="form-group">
                            <label for="custom-blockquote-color">å¼•ç”¨æ–‡æœ¬é¢œè‰²</label>
                            <input type="color" id="custom-blockquote-color" style="padding: 2px; height: 38px;">
                        </div>
                        <div class="form-group">
                            <label for="custom-blockquote-font-size-ratio">å¼•ç”¨å­—ä½“å¤§å° (å€ç‡)</label>
                            <input type="number" id="custom-blockquote-font-size-ratio" min="0.5" max="2" step="0.1">
                        </div>
                        <div class="form-group">
                            <label for="custom-blockquote-bg-color">å¼•ç”¨èƒŒæ™¯é¢œè‰²</label>
                            <input type="color" id="custom-blockquote-bg-color" style="padding: 2px; height: 38px;">
                        </div>
                        <div class="form-group">
                            <label for="custom-blockquote-border-color">å¼•ç”¨è¾¹æ¡†é¢œè‰²</label>
                            <input type="color" id="custom-blockquote-border-color" style="padding: 2px; height: 38px;">
                        </div>
                    </div>
                    <button id="reset-styles-button" class="btn-secondary" style="margin-top: 15px;">é‡ç½®æ‰€æœ‰è‡ªå®šä¹‰æ ·å¼</button>
                    <!-- END: MODIFIED SECTION -->

                    <hr style="margin: 20px 0;">
                    <h3>æ˜¾ç¤ºè®¾ç½®</h3>
                    <div class="form-group">
                        <label for="toggle-nicknames-checkbox" style="flex-direction: row; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="toggle-nicknames-checkbox" style="width: auto;">
                            <span style="font-weight: normal; margin-left: 10px;">æ˜¾ç¤ºæ¶ˆæ¯æ˜µç§°</span>
                        </label>
                    </div>
                    <!-- START: NEW HTML RENDER TOGGLE -->
                    <div class="form-group">
                        <label for="toggle-html-render-checkbox" style="flex-direction: row; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="toggle-html-render-checkbox" style="width: auto;">
                            <span style="font-weight: normal; margin-left: 10px;">åœ¨æ¶ˆæ¯æ°”æ³¡ä¸­æ¸²æŸ“HTMLå†…å®¹ (æœ‰é£é™©)</span>
                        </label>
                    </div>
                    <!-- END: NEW HTML RENDER TOGGLE -->
                </div>

                <!-- Data Management Tab -->
                <div id="data-tab" class="tab-content">
                    <h3>å¯¹è¯å†å²</h3>
                    <p>å½“å‰è¯é¢˜åŒ…å« <span id="message-count">0</span> æ¡æ¶ˆæ¯ã€‚</p>
                    <button id="clear-chat-button" class="btn-secondary" style="background: #e06c75; color: white;">æ¸…ç©ºå½“å‰è¯é¢˜</button>
                    <h3>åº”ç”¨æ•°æ®</h3>
                    <p>æ‰€æœ‰è®¾ç½®å’Œå¯¹è¯å†å²éƒ½ä¿å­˜åœ¨æ‚¨çš„æµè§ˆå™¨ä¸­ã€‚</p>
                    <button id="export-data-button" class="btn-secondary">å¯¼å‡ºæ‰€æœ‰æ•°æ®</button>
                    <label for="import-data-input" class="btn-secondary" style="display: inline-block; padding: 10px 20px; cursor: pointer;">å¯¼å…¥æ•°æ®</label>
                    <input type="file" id="import-data-input" accept=".json" hidden>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="close-settings-button" class="btn-secondary">å…³é—­</button>
            </div>
        </div>
    </div>

    <!-- Cropper Modal -->
    <div id="cropper-modal" class="modal">
        <div class="modal-content">
            <h2>è£å‰ªå¤´åƒ</h2>
            <div id="cropper-container">
                <img id="image-to-crop">
            </div>
            <div class="modal-buttons">
                <button id="crop-image-button" class="btn-primary">è£å‰ª</button>
                <button id="cancel-crop-button" class="btn-secondary">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    
    <!-- START: Character Selection Modal -->
    <div id="character-selection-modal" class="modal">
        <div class="modal-content">
            <h2>è§’è‰²é€‰æ‹©</h2>
            <div id="character-gallery-container" class="modal-body">
                <div id="character-gallery" class="character-gallery">
                    <!-- Character cards will be injected here -->
                    <div class="import-card-placeholder" onclick="document.getElementById('character-card-input').click()">
                        <div class="plus-icon">+</div>
                        <div>å¯¼å…¥æ–°è§’è‰²</div>
                    </div>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="close-character-selection-button" class="btn-secondary">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- END: Character Selection Modal -->

    <!-- START: Character Editor Modal -->
    <div id="character-editor-modal" class="modal">
        <div class="modal-content">
            <h2 id="character-editor-title">ç¼–è¾‘è§’è‰²</h2>
            <input type="hidden" id="editing-character-id">
            
            <div class="editor-tabs">
                <button class="tab-button active" data-tab="editor-basic-tab">åŸºæœ¬ä¿¡æ¯</button>
                <button class="tab-button" data-tab="editor-advanced-tab">é«˜çº§è®¾å®š</button>
                <button class="tab-button" data-tab="editor-book-tab">ä¸–ç•Œä¹¦</button>
                <!-- START: MODIFICATION - Add Regex Tab Button -->
                <button class="tab-button" data-tab="editor-regex-tab">æ­£åˆ™åå¤„ç†</button>
                <!-- END: MODIFICATION - Add Regex Tab Button -->
            </div>
            
            <div id="character-editor-body" class="modal-body">
                <!-- Basic Info Tab -->
                <div id="editor-basic-tab" class="tab-content active">
                    <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="char-edit-name">è§’è‰²åç§°</label>
                            <input type="text" id="char-edit-name" data-field="name">
                        </div>
                        <div class="form-group">
                            <label for="char-edit-tags">æ ‡ç­¾ (é€—å·åˆ†éš”)</label>
                            <input type="text" id="char-edit-tags" data-field="tags">
                        </div>
                    </div>
                    <div class="form-group form-group-full-width">
                        <label for="char-edit-description">æè¿°</label>
                        <textarea id="char-edit-description" rows="5" data-field="description"></textarea>
                    </div>
                    <div class="form-group form-group-full-width">
                        <label for="char-edit-personality">æ€§æ ¼</label>
                        <textarea id="char-edit-personality" rows="4" data-field="personality"></textarea>
                    </div>
                    <div class="form-group form-group-full-width">
                        <label for="char-edit-scenario">åœºæ™¯</label>
                        <textarea id="char-edit-scenario" rows="4" data-field="scenario"></textarea>
                    </div>
                    <div class="form-group form-group-full-width">
                        <label for="char-edit-first-message">é¦–æ¬¡é—®å€™</label>
                        <textarea id="char-edit-first-message" rows="5" data-field="first_mes"></textarea>
                    </div>
                     <div class="form-group form-group-full-width">
                        <label for="char-edit-message-example">ç¤ºä¾‹å¯¹è¯</label>
                        <textarea id="char-edit-message-example" rows="5" data-field="mes_example"></textarea>
                    </div>
                </div>

                <!-- Advanced Settings Tab -->
                <div id="editor-advanced-tab" class="tab-content">
                    <div class="form-group">
                        <label for="char-edit-system-prompt">ç³»ç»Ÿæç¤ºè¯ (System Prompt)</label>
                        <textarea id="char-edit-system-prompt" rows="6" data-field="system_prompt"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="char-edit-post-history">å†å²åæŒ‡ä»¤ (Post History Instructions)</label>
                        <textarea id="char-edit-post-history" rows="4" data-field="post_history_instructions"></textarea>
                    </div>
                     <div class="form-group">
                        <label for="char-edit-creator-notes">ä½œè€…å¤‡æ³¨</label>
                        <textarea id="char-edit-creator-notes" rows="3" data-field="creator_notes"></textarea>
                    </div>
                    <div class="form-group">
                        <label>å¤‡é€‰é—®å€™è¯­</label>
                        <div id="char-edit-alternate-greetings-container"></div>
                        <button id="add-alternate-greeting-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em; margin-top: 10px;">+ æ·»åŠ </button>
                    </div>
                </div>

                <!-- World Book Tab -->
                <div id="editor-book-tab" class="tab-content">
                     <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="char-edit-book-name">ä¹¦å</label>
                            <input type="text" id="char-edit-book-name" data-field="character_book.name">
                        </div>
                         <div class="form-group">
                            <label for="char-edit-book-desc">ä¹¦æœ¬æè¿°</label>
                            <input type="text" id="char-edit-book-desc" data-field="character_book.description">
                        </div>
                    </div>
                    <hr>
                    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4>æ¡ç›®åˆ—è¡¨</h4>
                        <button id="add-world-book-entry-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em;">+ æ·»åŠ æ¡ç›®</button>
                    </div>
                    <div id="char-edit-world-book-entries-container">
                        <!-- World book entries will be injected here -->
                    </div>
                </div>

                <!-- START: MODIFICATION - Add Regex Tab Content -->
                <div id="editor-regex-tab" class="tab-content">
                     <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4>è§’è‰²ä¸“å±æ­£åˆ™è§„åˆ™</h4>
                        <button id="add-char-regex-rule-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em;">+ æ·»åŠ è§„åˆ™</button>
                    </div>
                    <div id="char-edit-regex-container">
                        <!-- Character regex rules will be injected here -->
                    </div>
                </div>
                <!-- END: MODIFICATION - Add Regex Tab Content -->
            </div>
            
            <div class="modal-buttons">
                <button id="save-character-button" class="btn-primary">ä¿å­˜</button>
                <button id="close-character-editor-button" class="btn-secondary">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- END: Character Editor Modal -->

    <!-- START: MODIFIED Preset Editor Modal -->
    <div id="preset-editor-modal" class="modal">
        <div class="modal-content">
            <h2 id="preset-editor-title">å…¨å±€é¢„è®¾ç¼–è¾‘å™¨</h2>
            
            <div class="editor-form-grid" style="grid-template-columns: 1fr 1fr auto; align-items: flex-end; padding-bottom: 15px; border-bottom: 1px solid var(--modal-border-color); margin-bottom: 15px;">
                <div class="form-group">
                    <label for="preset-editor-selector">å½“å‰é¢„è®¾</label>
                    <select id="preset-editor-selector"></select>
                </div>
                <div class="form-group">
                    <label for="preset-name-input">é¢„è®¾åç§°</label>
                    <input type="text" id="preset-name-input" placeholder="ä¸ºé¢„è®¾å‘½å...">
                </div>
                <div class="form-group">
                    <button id="delete-preset-btn" class="btn-secondary" style="width: 100%; background-color: #e06c75; color: white;">åˆ é™¤</button>
                </div>
            </div>

            <div class="editor-tabs">
                <button class="tab-button active" data-tab="preset-main-tab">ä¸»è¦å‚æ•°</button>
                <button class="tab-button" data-tab="preset-context-tab">ä¸Šä¸‹æ–‡ä¸é™åˆ¶</button>
                <button class="tab-button" data-tab="preset-formatting-tab">æ ¼å¼åŒ–ä¸æ³¨å…¥</button>
                <button class="tab-button" data-tab="preset-prompts-tab">æç¤ºè¯æ³¨å…¥</button>
                <button class="tab-button" data-tab="preset-regex-tab">æ­£åˆ™åå¤„ç†</button>
            </div>
            
            <div id="preset-editor-body" class="modal-body">
                <!-- Main Parameters Tab -->
                <div id="preset-main-tab" class="tab-content active">
                    <h4>é‡‡æ ·å‚æ•°</h4>
                    <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="preset-temperature">Temperature: <span id="preset-temperature-value">1.42</span></label>
                            <input type="range" id="preset-temperature" min="0" max="2" step="0.01" value="1.42">
                        </div>
                        <div class="form-group">
                            <label for="preset-top-p">Top P: <span id="preset-top-p-value">0.99</span></label>
                            <input type="range" id="preset-top-p" min="0" max="1" step="0.01" value="0.99">
                        </div>
                        <div class="form-group">
                            <label for="preset-top-k">Top K</label>
                            <input type="number" id="preset-top-k" min="0" value="500">
                        </div>
                        <div class="form-group">
                            <label for="preset-top-a">Top A: <span id="preset-top-a-value">0</span></label>
                            <input type="range" id="preset-top-a" min="0" max="1" step="0.01" value="0">
                        </div>
                         <div class="form-group">
                            <label for="preset-min-p">Min P: <span id="preset-min-p-value">0</span></label>
                            <input type="range" id="preset-min-p" min="0" max="1" step="0.01" value="0">
                        </div>
                        <div class="form-group">
                            <label for="preset-repetition-penalty">Repetition Penalty: <span id="preset-repetition-penalty-value">1</span></label>
                            <input type="range" id="preset-repetition-penalty" min="1" max="2" step="0.01" value="1">
                        </div>
                        <div class="form-group">
                            <label for="preset-frequency-penalty">Frequency Penalty: <span id="preset-frequency-penalty-value">0</span></label>
                            <input type="range" id="preset-frequency-penalty" min="-2" max="2" step="0.01" value="0">
                        </div>
                         <div class="form-group">
                            <label for="preset-presence-penalty">Presence Penalty: <span id="preset-presence-penalty-value">0</span></label>
                            <input type="range" id="preset-presence-penalty" min="-2" max="2" step="0.01" value="0">
                        </div>
                    </div>
                </div>

                <!-- Context & Limits Tab -->
                <div id="preset-context-tab" class="tab-content">
                    <h4>ä¸Šä¸‹æ–‡ä¸Tokené™åˆ¶</h4>
                     <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="preset-openai-max-tokens">æœ€å¤§ç”ŸæˆTokens (Max Tokens)</label>
                            <input type="number" id="preset-openai-max-tokens" min="0" value="65535">
                        </div>
                        <div class="form-group">
                            <label for="preset-openai-max-context">æœ€å¤§ä¸Šä¸‹æ–‡é•¿åº¦</label>
                            <input type="number" id="preset-openai-max-context" min="0" value="777888">
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px;">
                        <label class="toggle-switch">
                            <input type="checkbox" id="preset-max-context-unlocked">
                            <span>è§£é”æœ€å¤§ä¸Šä¸‹æ–‡ (max_context_unlocked)</span>
                        </label>
                    </div>
                </div>

                <!-- Formatting & Injection Tab -->
                <div id="preset-formatting-tab" class="tab-content">
                    <h4>æ ¼å¼åŒ–ä¸è¡Œä¸ºæ§åˆ¶</h4>
                    <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="preset-names-behavior">è§’è‰²åè¡Œä¸º (names_behavior)</label>
                            <select id="preset-names-behavior">
                                <option value="0">é»˜è®¤</option>
                                <!-- åœ¨JSä¸­åŠ¨æ€æ·»åŠ æ›´å¤šé€‰é¡¹ -->
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="preset-bias-preset-selected">åå‘é¢„è®¾ (bias_preset)</label>
                            <input type="text" id="preset-bias-preset-selected" value="Default (none)">
                        </div>
                         <div class="form-group">
                            <label class="toggle-switch">
                                <input type="checkbox" id="preset-wrap-in-quotes">
                                <span>å›å¤åŒ…è£¹å¼•å· (wrap_in_quotes)</span>
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="toggle-switch">
                                <input type="checkbox" id="preset-stream-openai">
                                <span>æµå¼è¾“å‡º (stream_openai)</span>
                            </label>
                        </div>
                    </div>
                    <hr>
                    <div class="form-group">
                        <label for="preset-send-if-empty">ç©ºæ¶ˆæ¯å‘é€å†…å®¹ (send_if_empty)</label>
                        <input type="text" id="preset-send-if-empty">
                    </div>
                    <hr>
                    <h4>æ ¼å¼åŒ–æ¨¡æ¿</h4>
                     <div class="editor-form-grid">
                        <div class="form-group">
                            <label for="preset-wi-format">ä¸–ç•Œä¹¦æ ¼å¼ (wi_format)</label>
                            <input type="text" id="preset-wi-format" value="{0}">
                        </div>
                        <div class="form-group">
                            <label for="preset-scenario-format">åœºæ™¯æ ¼å¼ (scenario_format)</label>
                            <input type="text" id="preset-scenario-format" value="{{scenario}}">
                        </div>
                        <div class="form-group">
                            <label for="preset-personality-format">æ€§æ ¼æ ¼å¼ (personality_format)</label>
                            <input type="text" id="preset-personality-format" value="{{personality}}">
                        </div>
                    </div>
                </div>

                <!-- Advanced Prompts Tab -->
                <div id="preset-advanced-prompts-tab" class="tab-content" style="display:none;"> <!-- Initially hidden for simplicity, can be added to tabs if needed -->
                    <h4>é«˜çº§æç¤ºè¯æ¨¡æ¿</h4>
                    <div class="form-group">
                        <label for="preset-impersonation-prompt">æ¨¡æ‹Ÿæç¤ºè¯ (impersonation_prompt)</label>
                        <textarea id="preset-impersonation-prompt" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="preset-new-chat-prompt">æ–°èŠå¤©æç¤ºè¯ (new_chat_prompt)</label>
                        <textarea id="preset-new-chat-prompt" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="preset-continue-nudge-prompt">ç»§ç»­ç”Ÿæˆæç¤º (continue_nudge_prompt)</label>
                        <textarea id="preset-continue-nudge-prompt" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="preset-group-nudge-prompt">ç¾¤èŠæç¤º (group_nudge_prompt)</label>
                        <textarea id="preset-group-nudge-prompt" rows="3"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="preset-new-example-chat-prompt">æ–°ç¤ºä¾‹èŠå¤©æç¤º (new_example_chat_prompt)</label>
                        <textarea id="preset-new-example-chat-prompt" rows="3"></textarea>
                    </div>
                </div>

                <!-- Prompt Injection Tab -->
                <div id="preset-prompts-tab" class="tab-content">
                    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4>æç¤ºè¯æ¨¡å— (å¯æ‹–æ‹½æ’åº)</h4>
                        <button id="add-prompt-module-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em;">+ æ·»åŠ æ¨¡å—</button>
                    </div>
                    <div id="preset-prompts-container"></div>
                </div>

                <!-- Regex Post-processing Tab -->
                <div id="preset-regex-tab" class="tab-content">
                     <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h4>æ­£åˆ™åå¤„ç†è§„åˆ™</h4>
                        <button id="add-regex-rule-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em;">+ æ·»åŠ è§„åˆ™</button>
                    </div>
                    <div id="preset-regex-container"></div>
                </div>
            </div>
            
            <div class="modal-buttons">
                <button id="import-preset-btn" class="btn-secondary">å¯¼å…¥SillyTaverné¢„è®¾</button>
                <input type="file" id="preset-file-input" class="hidden" accept=".json">
                <button id="save-as-new-preset-btn" class="btn-secondary">å¦å­˜ä¸ºæ–°é¢„è®¾</button>
                <button id="save-preset-button" class="btn-primary">æ›´æ–°å½“å‰é¢„è®¾</button>
                <button id="close-preset-editor-button" class="btn-secondary">å…³é—­</button>
            </div>
        </div>
    </div>
    <!-- END: Preset Editor Modal -->


    <!-- START: Global World Book Editor Modal -->
    <div id="global-world-book-editor-modal" class="modal">
        <div class="modal-content">
            <h2 id="global-book-editor-title">ç¼–è¾‘ä¸–ç•Œä¹¦</h2>
            <input type="hidden" id="editing-global-book-id">
            <div class="modal-body">
                <div class="form-group">
                    <label for="global-book-edit-name">ä¹¦å</label>
                    <input type="text" id="global-book-edit-name" class="form-control">
                </div>
                <div class="form-group">
                    <label for="global-book-edit-desc">ä¹¦æœ¬æè¿°</label>
                    <textarea id="global-book-edit-desc" rows="3" class="form-control"></textarea>
                </div>
                <hr>
                <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h4>æ¡ç›®åˆ—è¡¨</h4>
                    <button id="add-global-book-entry-btn" class="btn-secondary" style="padding: 5px 10px; font-size: 0.9em;">+ æ·»åŠ æ¡ç›®</button>
                </div>
                <div id="global-book-edit-entries-container">
                    <!-- World book entries for the global book will be injected here -->
                </div>
            </div>
            <div class="modal-buttons">
                <button id="save-global-book-button" class="btn-primary">ä¿å­˜</button>
                <button id="close-global-book-editor-button" class="btn-secondary">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <!-- END: Global World Book Editor Modal -->


    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" defer></script></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js" defer></script></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js" defer></script></script>
    <script src="https://cdn.jsdelivr.net/npm/gpt-tokenizer@2.1.1/dist/index.browser.js" defer></script></script>
    <!-- Optional: SortableJS for drag-and-drop -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js" defer></script></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js" defer></script>


    <script>
    // =================================================================
    // START: IndexedDB Helper for Image Storage
    // =================================================================
    const ImageDB = {
        db: null,
        DB_NAME: 'CharacterCardDB',
        STORE_NAME: 'character_images',

        init() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    return resolve(this.db);
                }
                
                const request = indexedDB.open(this.DB_NAME, 2);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(this.STORE_NAME)) {
                        db.createObjectStore(this.STORE_NAME, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log('IndexedDB åˆå§‹åŒ–æˆåŠŸã€‚');
                    resolve(this.db);
                };

                request.onerror = (event) => {
                    console.error('IndexedDB é”™è¯¯:', event.target.errorCode);
                    reject(event.target.error);
                };
            });
        },

        addImage(id, imageDataUrl) {
            return new Promise((resolve, reject) => {
                if (!this.db) return reject('æ•°æ®åº“æœªåˆå§‹åŒ–ã€‚');
                
                const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
                const store = transaction.objectStore(this.STORE_NAME);
                const request = store.put({ id: id, data: imageDataUrl });

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        },

        getImage(id) {
            return new Promise((resolve, reject) => {
                if (!this.db) return reject('æ•°æ®åº“æœªåˆå§‹åŒ–ã€‚');

                const transaction = this.db.transaction([this.STORE_NAME], 'readonly');
                const store = transaction.objectStore(this.STORE_NAME);
                const request = store.get(id);

                request.onsuccess = (event) => {
                    if (event.target.result) {
                        resolve(event.target.result.data);
                    } else {
                        resolve(null); 
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        },

        deleteImage(id) {
            return new Promise((resolve, reject) => {
                if (!this.db) return reject('æ•°æ®åº“æœªåˆå§‹åŒ–ã€‚');

                const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
                const store = transaction.objectStore(this.STORE_NAME);
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }
    };
    // =================================================================
    // END: IndexedDB Helper
    // =================================================================

    document.addEventListener('DOMContentLoaded', () => {

        // =================================================================
        // START: è§’è‰²å¡è§£æå™¨æ ¸å¿ƒå‡½æ•°
        // =================================================================
        const PNG_SIGNATURE = [137, 80, 78, 71, 13, 10, 26, 10];

        function isValidPNG(bytes) {
            if (!bytes || bytes.length < 8) return false;
            for (let i = 0; i < PNG_SIGNATURE.length; i++) {
                if (bytes[i] !== PNG_SIGNATURE[i]) return false;
            }
            return true;
        }

        function decodeSafeBase64(base64) {
            try {
                const binary_string = atob(base64);
                const bytes = new Uint8Array(binary_string.length);
                for (let i = 0; i < binary_string.length; i++) {
                    bytes[i] = binary_string.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                console.error("Base64 decoding failed:", e);
                return atob(base64); // Fallback
            }
        }

        function extractChunkData(bytes, keyword) {
            let offset = 8;
            while (offset < bytes.length) {
                const view = new DataView(bytes.buffer);
                const length = view.getUint32(offset, false);
                const type = new TextDecoder().decode(bytes.slice(offset + 4, offset + 8));

                if (type === 'tEXt') {
                    const data = bytes.slice(offset + 8, offset + 8 + length);
                    const nullIndex = data.indexOf(0);
                    if (nullIndex !== -1) {
                        const key = new TextDecoder().decode(data.slice(0, nullIndex));
                        if (key === keyword) {
                            return new TextDecoder().decode(data.slice(nullIndex + 1));
                        }
                    }
                }
                if (type === 'IEND') break;
                offset += 12 + length;
            }
            return null;
        }
        // =================================================================
        // END: ç§»æ¤å‡½æ•°ç»“æŸ
        // =================================================================


        if (window.marked) {
            marked.setOptions({
                gfm: true,
                breaks: true,
            });
        }
        
        const themes = {
            'default-light': {
                name: 'Default Light',
                colors: {}
            },
            'default-dark': {
                name: 'Default Dark',
                colors: {
                    '--bg-color': '#282c34', '--text-color': '#abb2bf', '--primary-color': '#61afef',
                    '--secondary-color': '#c678dd', '--border-color': '#3b4048', '--panel-bg': '#21252b',
                    '--input-bg': '#3b4048', '--user-msg-bg': '#3a3f4b', '--ai-msg-bg': '#2c313a',
                    '--scrollbar-thumb': '#525965', '--scrollbar-track': '#21252b', '--code-bg': '#1e1f22',
                    '--text-color-muted': '#9e9e9e',
                    '--modal-bg': '#21252b', '--modal-text-color': '#abb2bf', '--modal-header-color': '#61afef',
                    '--modal-border-color': '#3b4048', '--modal-input-bg': '#3b4048',
                    '--modal-btn-primary-bg': '#61afef', '--modal-btn-primary-text': '#21252b',
                    '--modal-btn-secondary-bg': '#3b4048', '--modal-btn-secondary-text': '#abb2bf',
                }
            },
        };
        
        const systemPromptTemplates = {
            'default': { name: 'é»˜è®¤', prompt: '' },
            'translator': { name: 'ç¿»è¯‘ä¸“å®¶', prompt: 'ä½ æ˜¯ä¸€åä¸“ä¸šçš„ã€ç²¾é€šå¤šç§è¯­è¨€çš„ç¿»è¯‘å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯å‡†ç¡®åœ°ç¿»è¯‘ç”¨æˆ·æä¾›çš„æ–‡æœ¬ï¼ŒåŒæ—¶ä¿ç•™åŸæ–‡çš„å«ä¹‰ã€è¯­æ°”å’Œç»†å¾®å·®åˆ«ã€‚è¯·ç›´æ¥æä¾›ç¿»è¯‘ç»“æœï¼Œæ— éœ€ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–å®¢å¥—è¯ã€‚' },
            'programmer': { name: 'ç¼–ç¨‹å¤§å¸ˆ', prompt: 'ä½ æ˜¯ä¸€ä½é¡¶çº§çš„è½¯ä»¶å·¥ç¨‹å¸ˆå’Œç¼–ç¨‹ä¸“å®¶ã€‚è¯·æä¾›æ¸…æ™°ã€é«˜æ•ˆã€å¯ç»´æŠ¤ä¸”æœ‰è‰¯å¥½æ–‡æ¡£æ³¨é‡Šçš„ä»£ç ã€‚åœ¨æä¾›ä»£ç ä¹‹å‰æˆ–ä¹‹åï¼Œè¯·ç”¨ç®€æ´æ˜äº†çš„è¯­è¨€è§£é‡Šä½ çš„æ ¸å¿ƒé€»è¾‘ã€è®¾è®¡å†³ç­–ä»¥åŠå¦‚ä½•ä½¿ç”¨è¯¥ä»£ç ã€‚' },
            'copywriter': { name: 'è¥é”€æ–‡æ¡ˆ', prompt: 'ä½ æ˜¯ä¸€ä½å¯Œæœ‰åˆ›é€ åŠ›å’Œæ´å¯ŸåŠ›çš„è¥é”€æ–‡æ¡ˆå¤§å¸ˆã€‚è¯·ä¸ºå¹¿å‘Šã€ç¤¾äº¤åª’ä½“ã€ç½‘ç«™æˆ–é‚®ä»¶ç­‰åœºæ™¯ï¼Œåˆ›ä½œå‡ºå¼•äººæ³¨ç›®ã€å…·æœ‰è¯´æœåŠ›ä¸”èƒ½æ¿€å‘ç”¨æˆ·è¡ŒåŠ¨çš„æ–‡æ¡ˆã€‚' },
            'NeutralChat': { name: 'è§’è‰²æ‰®æ¼”', prompt: `Write {{char}}'s next reply in a fictional chat between {{char}} and {{user}}.` },
            'teacher': { name: 'è€å¿ƒå¯¼å¸ˆ', prompt: 'ä½ æ˜¯ä¸€ä½çŸ¥è¯†æ¸Šåšã€å……æ»¡è€å¿ƒçš„å¯¼å¸ˆã€‚è¯·ä½¿ç”¨ç®€å•æ˜“æ‡‚çš„è¯­è¨€ï¼Œé€šè¿‡ç±»æ¯”å’Œå®ä¾‹æ¥è§£é‡Šå¤æ‚çš„æ¦‚å¿µã€‚é¼“åŠ±ç”¨æˆ·æé—®ï¼Œå¹¶å¼•å¯¼ä»–ä»¬ç‹¬ç«‹æ€è€ƒï¼Œé€æ­¥æŒæ¡çŸ¥è¯†ã€‚' }
        };


        const DOMElements = {
            appContainer: document.getElementById('app-container'),
            menuToggleButton: document.getElementById('menu-toggle-button'),
            sidebarOverlay: document.getElementById('sidebar-overlay'),
            newChatButton: document.getElementById('new-chat-button'),
            conversationList: document.getElementById('conversation-list'),
            chatContainer: document.getElementById('chat-container'),
            messageInput: document.getElementById('message-input'),
            sendButton: document.getElementById('send-button'),
            uploadButton: document.getElementById('upload-button'),
            fileInput: document.getElementById('file-input'),
            attachmentPreviews: document.getElementById('attachment-previews'),
            settingsButton: document.getElementById('settings-button'),
            settingsModal: document.getElementById('settings-modal'),
            closeSettingsButton: document.getElementById('close-settings-button'),
            providerSelector: document.getElementById('provider-selector'),
            modelSelector: document.getElementById('model-selector'),
            providerList: document.getElementById('provider-list'),
            saveProviderButton: document.getElementById('save-provider-button'),
            providerId: document.getElementById('provider-id'),
            providerName: document.getElementById('provider-name'),
            apiUrl: document.getElementById('api-url'),
            apiKey: document.getElementById('api-key'),
            modelNames: document.getElementById('model-names'),
            streamToggle: document.getElementById('stream-toggle'),
            searchToggle: document.getElementById('search-toggle'),
            contextCount: document.getElementById('context-count'),
            systemPrompt: document.getElementById('system-prompt'),
            clearChatButton: document.getElementById('clear-chat-button'),
            exportDataButton: document.getElementById('export-data-button'),
            importDataInput: document.getElementById('import-data-input'),
            messageCount: document.getElementById('message-count'),
            themeSelector: document.getElementById('theme-selector'),
            tokenCountDisplay: document.getElementById('token-count-display'),
            userName: document.getElementById('user-name'),
            userDescription: document.getElementById('user-description'),
            userAvatarPreview: document.getElementById('user-avatar-preview'),
            userAvatarInput: document.getElementById('user-avatar-input'),
            saveUserProfile: document.getElementById('save-user-profile'),
            modelProfileList: document.getElementById('model-profile-list'),
            cropperModal: document.getElementById('cropper-modal'),
            imageToCrop: document.getElementById('image-to-crop'),
            cropImageButton: document.getElementById('crop-image-button'),
            cancelCropButton: document.getElementById('cancel-crop-button'),
            toggleNicknamesCheckbox: document.getElementById('toggle-nicknames-checkbox'),
            // START: NEW HTML RENDER ELEMENT
            toggleHtmlRenderCheckbox: document.getElementById('toggle-html-render-checkbox'),
            // END: NEW HTML RENDER ELEMENT
            chatSearchInput: document.getElementById('chat-search-input'),
            exportChatButton: document.getElementById('export-chat-button'), 
            headerConversationTitle: document.getElementById('header-conversation-title'),
            settingsButtonMobileTrigger: document.getElementById('settings-button-mobile-trigger'),
            mobileActionsMenu: document.getElementById('mobile-actions-menu'),
            providerSelectorMobile: document.getElementById('provider-selector-mobile'),
            modelSelectorMobile: document.getElementById('model-selector-mobile'),
            chatSearchInputMobile: document.getElementById('chat-search-input-mobile'),
            exportChatButtonMobile: document.getElementById('export-chat-button-mobile'),
            openFullSettingsButton: document.getElementById('open-full-settings-button'),
            apiEndpoint: document.getElementById('api-endpoint'),
            systemPromptTemplatesContainer: document.getElementById('system-prompt-templates-container'),
            globalSearchInput: document.getElementById('global-search-input'),
            // START: Character Card Elements
            openCharacterGalleryButton: document.getElementById('open-character-gallery-button'),
            characterCardInput: document.getElementById('character-card-input'),
            characterSelectionModal: document.getElementById('character-selection-modal'),
            characterGallery: document.getElementById('character-gallery'),
            closeCharacterSelectionButton: document.getElementById('close-character-selection-button'),
            characterEditorModal: document.getElementById('character-editor-modal'),
            closeCharacterEditorButton: document.getElementById('close-character-editor-button'),
            saveCharacterButton: document.getElementById('save-character-button'),
            editingCharacterId: document.getElementById('editing-character-id'),
            // END: Character Card Elements

            // START: MODIFIED Preset Editor Elements
            presetSelector: document.getElementById('preset-selector'),
            presetSelectorMobile: document.getElementById('preset-selector-mobile'),
            presetButton: document.getElementById('preset-button'),
            openPresetEditorButton: document.getElementById('open-preset-editor-button'),
            presetEditorModal: document.getElementById('preset-editor-modal'),
            presetEditorSelector: document.getElementById('preset-editor-selector'),
            presetNameInput: document.getElementById('preset-name-input'),
            deletePresetButton: document.getElementById('delete-preset-btn'),
            closePresetEditorButton: document.getElementById('close-preset-editor-button'),
            savePresetButton: document.getElementById('save-preset-button'),
            saveAsNewPresetButton: document.getElementById('save-as-new-preset-btn'),
            importPresetButton: document.getElementById('import-preset-btn'),
            presetFileInput: document.getElementById('preset-file-input'),
            // END: MODIFIED Preset Editor Elements

            // START: Global World Book Elements
            globalWorldBookEditorModal: document.getElementById('global-world-book-editor-modal'),
            globalBookEditorTitle: document.getElementById('global-book-editor-title'),
            editingGlobalBookId: document.getElementById('editing-global-book-id'),
            globalBookEditName: document.getElementById('global-book-edit-name'),
            globalBookEditDesc: document.getElementById('global-book-edit-desc'),
            addGlobalBookEntryBtn: document.getElementById('add-global-book-entry-btn'),
            globalBookEditEntriesContainer: document.getElementById('global-book-edit-entries-container'),
            saveGlobalBookButton: document.getElementById('save-global-book-button'),
            closeGlobalBookEditorButton: document.getElementById('close-global-book-editor-button'),
            globalWorldBooksListContainer: document.getElementById('global-world-books-list-container'),
            importGlobalBookButton: document.getElementById('import-global-book-button'),
            importGlobalBookInput: document.getElementById('import-global-book-input'),
            addNewGlobalBookButton: document.getElementById('add-new-global-book-button'),
            // END: Global World Book Elements

            // START: Custom Style Elements
            customFontSizeInput: document.getElementById('custom-font-size'),
            customTextColorInput: document.getElementById('custom-text-color'),
            customBgColorInput: document.getElementById('custom-bg-color'),
            customPrimaryColorInput: document.getElementById('custom-primary-color'),
            resetStylesButton: document.getElementById('reset-styles-button'),
            // START: New Italic/Blockquote elements
            customItalicColorInput: document.getElementById('custom-italic-color'),
            customItalicFontSizeRatioInput: document.getElementById('custom-italic-font-size-ratio'),
            customBlockquoteColorInput: document.getElementById('custom-blockquote-color'),
            customBlockquoteFontSizeRatioInput: document.getElementById('custom-blockquote-font-size-ratio'),
            customBlockquoteBgColorInput: document.getElementById('custom-blockquote-bg-color'),
            customBlockquoteBorderColorInput: document.getElementById('custom-blockquote-border-color'),
            // END: New Italic/Blockquote elements
            // END: Custom Style Elements
        };

        let state = {
            providers: [], 
            conversations: [], 
            currentConversationId: null,
            characterCards: [],
            globalWorldBooks: [],
            // NEW: Global Preset State
            presets: [],
            currentPresetId: null,
            // END: Global Preset State
            currentProviderIndex: 0, 
            currentModel: '',
            settings: {
                stream: true, search: false,
                contextCount: 10, showNicknames: true, theme: 'default-light',
                renderHtml: false, // NEW: HTML render setting
                // START: MODIFIED settings properties
                customStyles: {
                    messageFontSize: 16,
                    messageTextColor: null,
                    bgColor: null,
                    primaryColor: null,
                    italicColor: null,
                    italicFontSizeRatio: 1,
                    blockquoteColor: null,
                    blockquoteBgColor: null,
                    blockquoteBorderColor: null,
                    blockquoteFontSizeRatio: 1,
                }
                // END: MODIFIED settings properties
            },
            userProfile: { name: '', avatar: '', description: '' },
            modelProfiles: {},
            attachedFiles: [], abortController: null,
        };
        let cropper = null;
        let currentCroppingCallback = null;
        let promptSortable = null;

        const getCurrentConversation = () => state.conversations.find(c => c.id === state.currentConversationId);
        
        // NEW: Helper to get the current global preset
        const getCurrentPreset = () => state.presets.find(p => p.id === state.currentPresetId) || state.presets[0];

        const saveState = () => {
            const dataToSave = {
                providers: state.providers, 
                conversations: state.conversations,
                characterCards: state.characterCards,
                globalWorldBooks: state.globalWorldBooks,
                // NEW: Save presets to localStorage
                presets: state.presets,
                currentPresetId: state.currentPresetId,
                currentConversationId: state.currentConversationId,
                currentProviderIndex: state.currentProviderIndex,
                currentModel: state.currentModel, 
                settings: state.settings,
                userProfile: state.userProfile, 
                modelProfiles: state.modelProfiles,
            };
            localStorage.setItem('ai-chat-app-data', JSON.stringify(dataToSave));
        };

        const getDefaultPreset = () => ({
            id: 'default-' + Date.now(),
            name: 'é»˜è®¤é¢„è®¾',
            // Main Params
            temperature: 1.42,
            top_p: 0.99,
            top_k: 500,
            top_a: 0,
            min_p: 0,
            repetition_penalty: 1,
            frequency_penalty: 0,
            presence_penalty: 0,
            // Context & Limits
            openai_max_tokens: 65535,
            openai_max_context: 777888,
            max_context_unlocked: true,
            // Formatting & Behavior
            stream_openai: false,
            wrap_in_quotes: false,
            names_behavior: 0,
            bias_preset_selected: 'Default (none)',
            send_if_empty: "",
            wi_format: "{0}",
            scenario_format: "{{scenario}}",
            personality_format: "{{personality}}",
            // Advanced Prompts
            impersonation_prompt: "",
            new_chat_prompt: "",
            continue_nudge_prompt: "",
            group_nudge_prompt: "",
            new_example_chat_prompt: "",
            new_group_chat_prompt: "",
            // Core arrays
            prompts: [],
            regexes: []
        });

        const loadState = () => {
            const savedData = localStorage.getItem('ai-chat-app-data');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                state.characterCards = parsedData.characterCards || []; 
                state.globalWorldBooks = parsedData.globalWorldBooks || [];
                
                // Load conversations
                if (parsedData.chatHistory && !parsedData.conversations) {
                    const newConversation = { id: Date.now(), title: "é»˜è®¤å¯¹è¯", history: parsedData.chatHistory, tokenCount: 0, systemPrompt: '' };
                    state.conversations = [newConversation]; 
                    state.currentConversationId = newConversation.id;
                } else {
                    state.conversations = parsedData.conversations || [];
                    state.conversations.forEach(c => {
                        if (c.tokenCount === undefined) c.tokenCount = 0;
                        if (c.systemPrompt === undefined) c.systemPrompt = '';
                    });
                    state.currentConversationId = parsedData.currentConversationId || null;
                }

                // NEW: Load or Migrate Presets
                if (parsedData.presets && Array.isArray(parsedData.presets) && parsedData.presets.length > 0) {
                    state.presets = parsedData.presets;
                } else {
                    // Migration Logic: Move presets from old conversations to the new global list
                    const migratedPresets = [];
                    state.conversations.forEach(c => {
                        if (c.preset && c.preset.name) { // Check if it's a non-default preset
                             migratedPresets.push({
                                ...c.preset,
                                id: `migrated-${c.id}`,
                                name: `æ—§é¢„è®¾ (${c.title.substring(0, 10)})`
                            });
                        }
                        delete c.preset; // Clean up old data structure
                    });
                    if (migratedPresets.length > 0) {
                        state.presets.push(...migratedPresets);
                    }
                }
                
                if (state.presets.length === 0) {
                     state.presets.push(getDefaultPreset());
                }
                state.currentPresetId = parsedData.currentPresetId && state.presets.some(p => p.id === parsedData.currentPresetId) 
                    ? parsedData.currentPresetId 
                    : state.presets[0].id;


                state.providers = parsedData.providers || [];
                state.currentProviderIndex = parsedData.currentProviderIndex || 0;
                
                // START: MODIFIED settings loading
                const defaultSettings = { 
                    stream: true, search: false, contextCount: 10, showNicknames: true, theme: 'default-light',
                    renderHtml: false, // NEW: Add default for HTML rendering
                    customStyles: {
                        messageFontSize: 16, messageTextColor: null, bgColor: null, primaryColor: null,
                        italicColor: null, italicFontSizeRatio: 1,
                        blockquoteColor: null, blockquoteBgColor: null, blockquoteBorderColor: null, blockquoteFontSizeRatio: 1
                    }
                };
                // Deep merge customStyles to prevent new properties from being lost on load
                if (parsedData.settings) {
                    parsedData.settings.customStyles = { ...defaultSettings.customStyles, ...(parsedData.settings.customStyles || {}) };
                }
                state.settings = { ...defaultSettings, ...parsedData.settings };

                // Migration from old structure
                if (parsedData.settings && parsedData.settings.fontSize) {
                    state.settings.customStyles.messageFontSize = parsedData.settings.fontSize;
                    delete state.settings.fontSize;
                }
                if (parsedData.settings && parsedData.settings.customColors) {
                    state.settings.customStyles.messageTextColor = parsedData.settings.customColors.text;
                    state.settings.customStyles.bgColor = parsedData.settings.customColors.background;
                    state.settings.customStyles.primaryColor = parsedData.settings.customColors.primary;
                    delete state.settings.customColors;
                }
                // END: MODIFIED settings loading

                const defaultUserProfile = { name: '', avatar: '', description: '' };
                state.userProfile = { ...defaultUserProfile, ...(parsedData.userProfile || {}) };
                state.modelProfiles = parsedData.modelProfiles || {};
            } 
            if (state.providers.length === 0) {
                state.providers.push({
                    id: Date.now(), name: 'é»˜è®¤ç¤ºä¾‹ (è¯·ä¿®æ”¹)', url: 'https://api.openai.com/v1',
                    endpoint: '/chat/completions', key: 'YOUR_API_KEY_HERE', models: 'gpt-4,gpt-3.5-turbo'
                });
            }
            if (state.conversations.length === 0 || !getCurrentConversation()) {
                createNewConversation(false); // create without rendering/saving yet
            }
        };
        
        // START: NEW custom style application function
        const applyCustomStyles = () => {
            const styles = state.settings.customStyles;
            const root = document.documentElement;
            
            // Helper function to set or remove a CSS property
            const setStyle = (prop, value) => {
                if (value) {
                    root.style.setProperty(prop, value);
                } else {
                    root.style.removeProperty(prop);
                }
            };

            // Apply global UI styles
            setStyle('--bg-color', styles.bgColor);
            setStyle('--primary-color', styles.primaryColor);
            
            // Apply Message-specific styles (THE FIX)
            setStyle('--message-font-size', styles.messageFontSize ? `${styles.messageFontSize}px` : null);
            setStyle('--message-text-color', styles.messageTextColor);
            
            // Dependent styles that should also change with the primary color
            if (styles.primaryColor) {
                setStyle('--modal-header-color', styles.primaryColor);
                setStyle('--modal-btn-primary-bg', styles.primaryColor);
            } else {
                // If primary color is cleared, let them fall back to theme defaults
                root.style.removeProperty('--modal-header-color');
                root.style.removeProperty('--modal-btn-primary-bg');
            }

            // New text element styles
            setStyle('--italic-color', styles.italicColor);
            setStyle('--italic-font-size-ratio', styles.italicFontSizeRatio || 1);
            setStyle('--blockquote-color', styles.blockquoteColor);
            setStyle('--blockquote-font-size-ratio', styles.blockquoteFontSizeRatio || 1);
            setStyle('--blockquote-bg-color', styles.blockquoteBgColor);
            setStyle('--blockquote-border-color', styles.blockquoteBorderColor);
        };
        // END: NEW function

        const applyTheme = (themeName) => {
            // This is important: clear previous custom inline styles before applying a new theme
            document.documentElement.style.cssText = '';
            const theme = themes[themeName];
            if (theme && theme.colors) {
                for (const [key, value] of Object.entries(theme.colors)) {
                    document.documentElement.style.setProperty(key, value);
                }
            }
        };

        const applyNicknameVisibility = () => {
            if (state.settings.showNicknames) {
                DOMElements.chatContainer.classList.remove('hide-nicknames');
            } else {
                DOMElements.chatContainer.classList.add('hide-nicknames');
            }
        };
        
        const calculateTextTokens = (text) => {
            if (typeof text !== 'string' || !text) return 0;
            try {
                if (window.gptTokenizer) {
                    return gptTokenizer.encode(text).length;
                }
            } catch (e) {
                console.error("Token calculation failed:", e);
            }
            return Math.ceil(text.length / 4);
        };

        const recalculateTotalTokens = async () => {
            const conversation = getCurrentConversation();
            if (!conversation) return;

            let totalTokens = 0;
            if(conversation.systemPrompt) {
                totalTokens += calculateTextTokens(conversation.systemPrompt);
            }

            conversation.history.forEach(msg => {
                if (typeof msg.content === 'string') {
                    totalTokens += calculateTextTokens(msg.content);
                } else if (Array.isArray(msg.content)) {
                    msg.content.forEach(part => {
                        if (part.type === 'text') {
                            totalTokens += calculateTextTokens(part.text);
                        }
                    });
                }
            });
            
            conversation.tokenCount = totalTokens;
            renderTokenCount();
        };


        const renderTokenCount = () => {
            const conversation = getCurrentConversation();
            if (conversation) {
                DOMElements.tokenCountDisplay.textContent = `(Tokens: ${conversation.tokenCount || 0})`;
            }
        };
        
        const renderHeaderTitle = () => {
             const conversation = getCurrentConversation();
             if(conversation) {
                DOMElements.headerConversationTitle.textContent = conversation.title;
             }
        }

        const renderChatHistory = () => {
            DOMElements.chatContainer.innerHTML = '';
            const conversation = getCurrentConversation();
            if (conversation) {
                conversation.history.forEach((msg, index) => {
                    if (!msg.internal) {
                         appendMessage(msg, index);
                    }
                });
                DOMElements.messageCount.textContent = conversation.history.filter(m => !m.internal).length;
            } else { DOMElements.messageCount.textContent = 0; }
            DOMElements.chatContainer.scrollTop = DOMElements.chatContainer.scrollHeight;
            recalculateTotalTokens(); 
        };

        const renderConversationsList = () => {
            DOMElements.conversationList.innerHTML = '';
            const sortedConversations = [...state.conversations].sort((a, b) => b.id - a.id);
            sortedConversations.forEach(conv => {
                const li = document.createElement('li');
                li.className = 'conversation-item';
                if (conv.id === state.currentConversationId) li.classList.add('active');
                li.dataset.id = conv.id; li.onclick = () => switchConversation(conv.id);
                const titleSpan = document.createElement('span'); titleSpan.textContent = conv.title;
                li.appendChild(titleSpan);
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-conversation-btn'; deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                deleteBtn.title = 'åˆ é™¤è¯é¢˜';
                deleteBtn.onclick = (e) => { e.stopPropagation(); window.app.deleteConversation(conv.id); };
                li.appendChild(deleteBtn);
                DOMElements.conversationList.appendChild(li);
            });
        };
        
        const syncSelectors = (source, target) => {
            target.innerHTML = source.innerHTML;
            target.value = source.value;
        };
        
        const renderProviders = () => {
            const selectors = [DOMElements.providerSelector, DOMElements.providerSelectorMobile];
            selectors.forEach(s => s.innerHTML = '');

            state.providers.forEach((provider, index) => {
                const option = document.createElement('option');
                option.value = index; option.textContent = provider.name;
                selectors.forEach(s => s.appendChild(option.cloneNode(true)));
            });

            if (state.providers.length > 0) {
                selectors.forEach(s => s.value = state.currentProviderIndex);
                renderModels(state.currentProviderIndex);
            }

            DOMElements.providerList.innerHTML = '';
            state.providers.forEach((provider, index) => {
                const item = document.createElement('div');
                item.className = 'provider-item';
                item.innerHTML = `<span>${provider.name}</span><div><button onclick="window.app.editProvider(${index})">âœï¸</button><button onclick="window.app.deleteProvider(${index})">ğŸ—‘ï¸</button></div>`;
                DOMElements.providerList.appendChild(item);
            });
        };
        
        const renderModels = (providerIndex) => {
            const selectors = [DOMElements.modelSelector, DOMElements.modelSelectorMobile];
            selectors.forEach(s => s.innerHTML = '');

            const provider = state.providers[providerIndex];
            if (provider && provider.models) {
                const models = provider.models.split(',').map(m => m.trim());
                models.forEach(model => {
                    if (model) {
                        const option = document.createElement('option');
                        option.value = model; option.textContent = model;
                        selectors.forEach(s => s.appendChild(option.cloneNode(true)));
                    }
                });
                
                let modelToSet = state.currentModel && models.includes(state.currentModel) ? state.currentModel : (models.length > 0 ? models[0] : '');
                
                selectors.forEach(s => s.value = modelToSet);
                if(state.currentModel !== modelToSet) {
                    state.currentModel = modelToSet;
                }
            }
        };

        // NEW: Renders all preset selectors
        const renderPresetSelectors = () => {
            const selectors = [DOMElements.presetSelector, DOMElements.presetSelectorMobile, DOMElements.presetEditorSelector];
            selectors.forEach(s => {
                if(s) s.innerHTML = '';
            });

            state.presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectors.forEach(s => {
                    if(s) s.appendChild(option.cloneNode(true));
                });
            });

            selectors.forEach(s => {
                if(s) s.value = state.currentPresetId;
            });
        };
        
        const renderThemeSelector = () => {
            DOMElements.themeSelector.innerHTML = '';
            for (const [key, theme] of Object.entries(themes)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = theme.name;
                DOMElements.themeSelector.appendChild(option);
            }
            DOMElements.themeSelector.value = state.settings.theme;
        };
        
        const renderSystemPromptTemplates = () => {
            DOMElements.systemPromptTemplatesContainer.innerHTML = '';
            for (const key in systemPromptTemplates) {
                const template = systemPromptTemplates[key];
                const button = document.createElement('button');
                button.textContent = template.name;
                button.type = "button";
                button.onclick = () => {
                    DOMElements.systemPrompt.value = template.prompt;
                    DOMElements.systemPrompt.dispatchEvent(new Event('change')); 
                };
                DOMElements.systemPromptTemplatesContainer.appendChild(button);
            }
        };

        const renderSettings = () => {
            const currentConv = getCurrentConversation();
            DOMElements.streamToggle.checked = state.settings.stream;
            DOMElements.searchToggle.checked = state.settings.search;
            DOMElements.contextCount.value = state.settings.contextCount;
            DOMElements.toggleNicknamesCheckbox.checked = state.settings.showNicknames;
            DOMElements.toggleHtmlRenderCheckbox.checked = state.settings.renderHtml; // NEW: Set HTML render checkbox state
            if (currentConv) {
                DOMElements.systemPrompt.value = currentConv.systemPrompt || '';
            }
            renderThemeSelector();

            // START: MODIFIED render settings for custom styles
            const styles = state.settings.customStyles;
            const computedStyles = getComputedStyle(document.documentElement);
            
            // Base styles
            DOMElements.customFontSizeInput.value = styles.messageFontSize;
            DOMElements.customTextColorInput.value = styles.messageTextColor || computedStyles.getPropertyValue('--message-text-color').trim();
            DOMElements.customBgColorInput.value = styles.bgColor || computedStyles.getPropertyValue('--bg-color').trim();
            DOMElements.customPrimaryColorInput.value = styles.primaryColor || computedStyles.getPropertyValue('--primary-color').trim();

            // New elements
            DOMElements.customItalicColorInput.value = styles.italicColor || computedStyles.getPropertyValue('--italic-color').trim();
            DOMElements.customItalicFontSizeRatioInput.value = styles.italicFontSizeRatio;
            DOMElements.customBlockquoteColorInput.value = styles.blockquoteColor || computedStyles.getPropertyValue('--blockquote-color').trim();
            DOMElements.customBlockquoteFontSizeRatioInput.value = styles.blockquoteFontSizeRatio;
            DOMElements.customBlockquoteBgColorInput.value = styles.blockquoteBgColor || computedStyles.getPropertyValue('--blockquote-bg-color').trim();
            DOMElements.customBlockquoteBorderColorInput.value = styles.blockquoteBorderColor || computedStyles.getPropertyValue('--blockquote-border-color').trim();
            // END: MODIFIED render settings

            DOMElements.userName.value = state.userProfile.name || '';
            DOMElements.userDescription.value = state.userProfile.description || '';
            DOMElements.userAvatarPreview.innerHTML = state.userProfile.avatar ? `<img src="${state.userProfile.avatar}" alt="User Avatar" loading="lazy">` : 'U';
            renderModelProfiles();
            renderSystemPromptTemplates();
            renderGlobalWorldBooksList();
        };
        
        const renderModelProfiles = () => {
            DOMElements.modelProfileList.innerHTML = '';
            const provider = state.providers[state.currentProviderIndex];
            if (!provider || !provider.models) return;
            
            const models = provider.models.split(',').map(m => m.trim()).filter(Boolean);
            models.forEach(modelName => {
                const profile = state.modelProfiles[modelName] || { nickname: '', avatar: '' };
                const item = document.createElement('div');
                item.className = 'model-profile-item';
                
                item.innerHTML = `
                    <div class="avatar-setting">
                        <div class="avatar-preview" onclick="document.getElementById('model-avatar-input-${modelName}').click()">
                            ${profile.avatar ? `<img src="${profile.avatar}" alt="${modelName} avatar" loading="lazy">` : 'AI'}
                        </div>
                        <input type="file" id="model-avatar-input-${modelName}" data-model="${modelName}" accept="image/*" class="hidden model-avatar-input">
                    </div>
                    <div class="form-group" style="flex-grow: 1; position: relative;">
                        <label for="model-nickname-${modelName}">${modelName}</label>
                        <input type="text" id="model-nickname-${modelName}" class="model-nickname-input" data-model="${modelName}" value="${profile.nickname}" placeholder="è‡ªå®šä¹‰æ˜µç§°">
                    </div>
                `;
                DOMElements.modelProfileList.appendChild(item);
            });
        };

        const appendMessage = (msg, index) => {
    const { role, content } = msg;
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    messageDiv.dataset.messageIndex = index;
    
    const avatarDiv = document.createElement('div');
    avatarDiv.className = 'avatar';
    
    const contentWrapper = document.createElement('div');
    
    const headerDiv = document.createElement('div');
    headerDiv.className = 'message-header';

    const currentConv = getCurrentConversation();
    const characterProfile = currentConv ? currentConv.characterProfile : null;

    if (role === 'user') {
        avatarDiv.innerHTML = state.userProfile.avatar ? `<img src="${state.userProfile.avatar}" alt="User Avatar" loading="lazy">` : 'U';
        headerDiv.textContent = state.userProfile.name || 'User';
    } else { 
        if (characterProfile && characterProfile.avatar) {
            avatarDiv.innerHTML = `<img src="${characterProfile.avatar}" alt="${characterProfile.name} Avatar" loading="lazy">`;
            headerDiv.textContent = characterProfile.name;
        } else {
            const modelUsed = msg.model || state.currentModel;
            const modelProfile = state.modelProfiles[modelUsed] || {};
            avatarDiv.innerHTML = modelProfile.avatar ? `<img src="${modelProfile.avatar}" alt="${modelUsed} avatar" loading="lazy">` : 'AI';
            headerDiv.textContent = modelProfile.nickname || modelUsed || 'AI';
        }
    }
    
    const contentDiv = document.createElement('div');
    contentDiv.className = 'content';
    
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'message-controls';
    
    let controlsHTML = `<button onclick="window.app.editMessage(${index})" title="ç¼–è¾‘">âœï¸</button><button onclick="window.app.copyMessage(event, ${index})" title="å¤åˆ¶">ğŸ“‹</button><button onclick="window.app.forkConversation(${index})" title="åˆ›å»ºåˆ†æ”¯">ğŸ´</button>`;
    if (role === 'user') {
        controlsHTML += `<button onclick="window.app.resendMessage(${index})" title="é‡æ–°å‘é€">ğŸ”„</button>`;
    } else {
        controlsHTML += `<button onclick="window.app.regenerateResponse(${index})" title="é‡æ–°ç”Ÿæˆ">ğŸ”„</button>`;
    }
    controlsHTML += `<button onclick="window.app.deleteMessage(${index})" title="åˆ é™¤">ğŸ—‘ï¸</button>`;
    controlsDiv.innerHTML = controlsHTML;
    
    messageDiv.appendChild(controlsDiv);
    updateMessageContent(contentDiv, content, role);

    // ğŸ†• æ–°å¢ï¼šä¸ºè§’è‰²å¡ç¬¬ä¸€æ¡æ¶ˆæ¯æ·»åŠ å¤‡é€‰é—®å€™è¯­åˆ‡æ¢æŒ‰é’®
    if (role === 'assistant' && index === 0 && characterProfile && characterProfile.cardId) {
        const card = state.characterCards.find(c => c.id === characterProfile.cardId);
        const altGreetings = card?.cardData?.alternate_greetings;
        
        if (altGreetings && altGreetings.length > 0) {
            const switchBtn = document.createElement('button');
            switchBtn.className = 'greeting-switch-btn';
            switchBtn.innerHTML = 'â†’';
            switchBtn.title = 'åˆ‡æ¢é—®å€™è¯­';
            switchBtn.onclick = (e) => {
                e.stopPropagation();
                window.app.switchGreeting(index);
            };
            contentDiv.appendChild(switchBtn);
        }
    }

    contentWrapper.appendChild(headerDiv);
    contentWrapper.appendChild(contentDiv);

    if (role === 'user') {
        messageDiv.appendChild(contentWrapper); 
        messageDiv.appendChild(avatarDiv);
    } else {
        messageDiv.appendChild(avatarDiv); 
        messageDiv.appendChild(contentWrapper);
    }
    DOMElements.chatContainer.appendChild(messageDiv);
    DOMElements.chatContainer.scrollTop = DOMElements.chatContainer.scrollHeight;
    return contentDiv;
};

        
        const getProcessedText = (text) => {
            if (typeof text !== 'string') return text;
            
            const currentConv = getCurrentConversation();
            const userName = state.userProfile.name || 'User';
            const charName = currentConv?.characterProfile?.name;

            let processedText = text.replace(/{{user}}/g, userName);
            if (charName) {
                processedText = processedText.replace(/{{char}}/g, charName);
            }
            return processedText;
        };
        
        function updateMessageContent(contentDiv, content, role) {
            contentDiv.innerHTML = '';
            
            let processedContent = content;

            // START: MODIFICATION - Combine Preset and Character Regex Rules
            if (role === 'assistant') {
                const preset = getCurrentPreset();
                const presetRules = (preset?.regexes && Array.isArray(preset.regexes)) ? preset.regexes : [];

                let characterRules = [];
                const currentConv = getCurrentConversation();
                if (currentConv && currentConv.characterProfile && currentConv.characterProfile.cardId) {
                    const characterCard = state.characterCards.find(c => c.id === currentConv.characterProfile.cardId);
                    if (characterCard && characterCard.cardData) {
                        const cardData = characterCard.cardData;
                        // Check both possible paths for regex scripts, prioritizing the standard SillyTavern path.
                        const cardRules = cardData.extensions?.chub?.extensions?.regex_scripts || cardData.extensions?.regex_scripts || [];
                        characterRules = cardRules;
                    }
                }
                
                const allRules = [...presetRules, ...characterRules];

                if (allRules.length > 0) {
                    allRules.forEach(rule => {
                        if (rule && !rule.disabled && rule.findRegex && typeof rule.replaceString === 'string') {
                            try {
                                const patternParts = rule.findRegex.match(/^\/(.*)\/([gimsuy]*)$/);
                                if (patternParts) {
                                    const regex = new RegExp(patternParts[1], patternParts[2]);
                                    processedContent = processedContent.replace(regex, rule.replaceString);
                                } else {
                                    const regex = new RegExp(rule.findRegex, 'g');
                                    processedContent = processedContent.replace(regex, rule.replaceString);
                                }
                            } catch (e) {
                                console.error(`æ— æ•ˆçš„æ­£åˆ™è¡¨è¾¾å¼è§„åˆ™ "${rule.scriptName || 'æœªå‘½å'}":`, e);
                            }
                        }
                    });
                }
            }
            // END: MODIFICATION - Combine Preset and Character Regex Rules

            const statusPayload = role === 'assistant' ? extractStatusBlockSegments(processedContent) : null;
            if (statusPayload) {
                renderStatusBlockInto(contentDiv, statusPayload);
                processedContent = statusPayload.remainingText || '';
            }

            if (role === 'user') {
                if (Array.isArray(content)) {
                    const attachments = content.filter(p => p.type === 'text_attachment' || p.type === 'image_url');
                    const textParts = content.filter(p => p.type === 'text');
                    if (attachments.length > 0) {
                        const attachmentContainer = document.createElement('div');
                        attachmentContainer.className = 'message-attachment-container';
                        attachments.forEach(part => {
                            if (part.type === 'image_url') {
                                const img = document.createElement('img');
                                img.src = part.image_url.url;
                                img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.borderRadius = '8px';
                                attachmentContainer.appendChild(img);
                            } else if (part.type === 'text_attachment') {
                                const attachmentDiv = document.createElement('div');
                                attachmentDiv.className = 'message-attachment';
                                attachmentDiv.innerHTML = `<span>ğŸ“</span><span>${part.name}</span>`;
                                attachmentContainer.appendChild(attachmentDiv);
                            }
                        });
                        contentDiv.appendChild(attachmentContainer);
                    }
                    if (textParts.length > 0) {
                        const p = document.createElement('p');
                        p.textContent = getProcessedText(textParts.map(p => p.text).join('\n'));
                        p.style.whiteSpace = 'pre-wrap';
                        contentDiv.appendChild(p);
                    }
                } else {
                    const p = document.createElement('p');
                    p.textContent = getProcessedText(content);
                    contentDiv.appendChild(p);
                }
                return;
            }

            const fencedFullDocRegex = /(?:```|~~~)html\s*\n([\s\S]*?<\/html>)\n\s*(?:```|~~~)/i;
            const bareFullDocRegex = /((?:<!DOCTYPE html[\s\S]*?)?<html(?:[^>]*?)>[\s\S]*?<\/html>)/i;
            const styleFragmentRegex = /<style>[\s\S]*?<\/style>/i;
            
            let fullDocMatch = processedContent.match(fencedFullDocRegex);
            if (!fullDocMatch) {
                fullDocMatch = processedContent.match(bareFullDocRegex);
            }
            const styleFragmentMatch = processedContent.match(styleFragmentRegex);

            let isRenderable = false;
            let beforeContent = '', contentToRender = '', afterContent = '';
            let renderMode = '';

            if (state.settings.renderHtml && role === 'assistant') {
                if (fullDocMatch) {
                    isRenderable = true;
                    renderMode = 'full';
                    beforeContent = processedContent.substring(0, fullDocMatch.index);
                    contentToRender = fullDocMatch[1]; 
                    afterContent = processedContent.substring(fullDocMatch.index + fullDocMatch[0].length);
                } else if (styleFragmentMatch) {
                    isRenderable = true;
                    renderMode = 'fragment';
                    contentToRender = processedContent; 
                }
            }

            if (isRenderable) {
                let htmlForIframe = '';

                if (renderMode === 'full') {
                    htmlForIframe = contentToRender.replace(/<style>([\s\S]*?)<\/style>/i, (match, styleContent) => {
                        const sanitized = styleContent.replace(/body\s*\{[^\}]+\}/i, `body { margin: 10px !important; background-color: transparent !important; }`);
                        return `<style>${sanitized}</style>`;
                    });
                } else if (renderMode === 'fragment') {
                    const styles = [];
                    const contentWithoutStyles = contentToRender.replace(/<style>([\s\S]*?)<\/style>/gi, (match, styleContent) => {
                      styles.push(styleContent);
                      return '';
                    });

                    const sanitizedBody = window.DOMPurify
                      ? DOMPurify.sanitize(contentWithoutStyles, { ADD_ATTR: ['style'] })
                      : contentWithoutStyles;

                    htmlForIframe = `
                      <!DOCTYPE html>
                      <html lang="zh-CN">
                      <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <style>
                          body {
                            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
                            background: transparent; margin: 0; padding: 10px;
                          }
                          a { color: ${getComputedStyle(document.body).getPropertyValue('--primary-color')}; }
                          ${styles.join('\n')}
                        </style>
                      </head>
                      <body>${sanitizedBody}</body>
                      </html>`;
                }

                if (beforeContent.trim()) {
                    const beforeDiv = document.createElement('div');
                    beforeDiv.innerHTML = simpleMarkdown(getProcessedText(beforeContent));
                    contentDiv.appendChild(beforeDiv);
                    enhanceCodeBlocks(beforeDiv);
                }
                
                const renderContainer = document.createElement('div');
                renderContainer.className = 'render-container';
                const iframe = document.createElement('iframe');
                iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-forms'); 
                iframe.style.border = 'none';
                iframe.style.backgroundColor = 'transparent';
                
                renderContainer.appendChild(iframe);
                contentDiv.appendChild(renderContainer);
                
                iframe.srcdoc = htmlForIframe;
                
                iframe.onload = () => {
                  try {
                    const messageDiv = contentDiv.closest('.message');
                    setTimeout(() => {
                      const doc = iframe.contentDocument || iframe.contentWindow.document;
                      const docEl = doc.documentElement;
                      const body = doc.body;

                      const contentWidth  = Math.max(
                        docEl.scrollWidth, body.scrollWidth, docEl.offsetWidth, body.offsetWidth
                      );
                      const contentHeight = Math.max(
                        docEl.scrollHeight, body.scrollHeight, docEl.offsetHeight, body.offsetHeight
                      );

                      const chatContainerWidth = DOMElements.chatContainer.clientWidth;
                      const maxAvailableWidth = chatContainerWidth - 80;
                      const breathingRoom = 10;

                      messageDiv.classList.remove('message-render-expand');
                      iframe.style.transform = '';
                      renderContainer.style.width = 'auto';
                      renderContainer.style.height = 'auto';

                      if (contentWidth > maxAvailableWidth) {
                        const scale = maxAvailableWidth / contentWidth;
                        renderContainer.style.width = `${maxAvailableWidth}px`;
                        renderContainer.style.height = `${Math.ceil(contentHeight * scale) + breathingRoom}px`;
                        iframe.style.width = `${contentWidth}px`;
                        iframe.style.height = `${contentHeight}px`;
                        iframe.style.transform = `scale(${scale})`;
                        iframe.style.transformOrigin = 'top left';
                      } else {
                        messageDiv.classList.add('message-render-expand');
                        iframe.style.width  = `${contentWidth  + breathingRoom}px`;
                        iframe.style.height = `${contentHeight + breathingRoom}px`;
                      }
                    }, 200);
                  } catch (e) {
                    console.error("Error adjusting iframe size:", e);
                    iframe.style.width = '100%';
                    iframe.style.height = '150px';
                  }
                };

                if (afterContent.trim()) {
                    const afterDiv = document.createElement('div');
                    afterDiv.innerHTML = simpleMarkdown(getProcessedText(afterContent));
                    contentDiv.appendChild(afterDiv);
                    enhanceCodeBlocks(afterDiv);
                }

            } else {
                const displayText = getProcessedText(processedContent);
                contentDiv.innerHTML = simpleMarkdown(displayText);
                enhanceCodeBlocks(contentDiv);
            }
        }
        
        const createNewConversation = (doRenderAndSave = true) => {
            const newConversation = { 
                id: Date.now(), 
                title: 'æ–°è¯é¢˜', 
                history: [], 
                tokenCount: 0, 
                systemPrompt: '',
                characterProfile: null
            };
            state.conversations.push(newConversation);
            state.currentConversationId = newConversation.id;
            
            if (doRenderAndSave) {
                renderAll(); 
                saveState();
            }

            if (DOMElements.appContainer.classList.contains('sidebar-visible')) {
                DOMElements.appContainer.classList.remove('sidebar-visible');
            }
        };

        const switchConversation = (id) => {
            if (state.currentConversationId === id) {
                 if (DOMElements.appContainer.classList.contains('sidebar-visible')) {
                    DOMElements.appContainer.classList.remove('sidebar-visible');
                }
                return;
            };
            state.currentConversationId = id;
            const searchInputs = [DOMElements.chatSearchInput, DOMElements.chatSearchInputMobile];
            searchInputs.forEach(input => {
                input.value = '';
                input.dispatchEvent(new Event('input'));
            });

            renderAll(); saveState();
            if (DOMElements.appContainer.classList.contains('sidebar-visible')) {
                DOMElements.appContainer.classList.remove('sidebar-visible');
            }
        };

        const renderAll = () => { 
            renderConversationsList(); 
            renderChatHistory(); 
            renderSettings(); 
            renderHeaderTitle();
            renderTokenCount();
            renderProviders();
            renderPresetSelectors();
            renderCharacterCards();
            renderGlobalWorldBooksList();
        };

        const buildApiMessages = (conversation) => {
            const preset = getCurrentPreset() || getDefaultPreset();
            const prompts = preset.prompts || [];

            let contextTimeline = [];
            
            let finalSystemPromptParts = [];
            if (state.userProfile.name || state.userProfile.description) {
                let userProfileString = `[User Profile]\nName: ${state.userProfile.name || 'N/A'}\nDescription: ${state.userProfile.description || 'N/A'}`;
                finalSystemPromptParts.push(userProfileString);
            }
            if (conversation.characterProfile && conversation.characterProfile.cardId) {
                const characterCard = state.characterCards.find(c => c.id === conversation.characterProfile.cardId);
                if (characterCard) {
                    finalSystemPromptParts.push(buildSystemPromptFromCard(characterCard.cardData));
                }
            }
            
            const enabledGlobalBooks = state.globalWorldBooks.filter(b => b.enabled);
            if (enabledGlobalBooks.length > 0) {
                let globalWorldBookContent = "\n\n---\n# å…¨å±€ä¸–ç•Œä¹¦ / èƒŒæ™¯çŸ¥è¯†\nè¿™æ˜¯é€‚ç”¨äºæ‰€æœ‰å¯¹è¯çš„é¢å¤–èƒŒæ™¯ä¿¡æ¯ã€‚å½“å¯¹è¯ä¸­å‡ºç°ç›¸å…³â€œå…³é”®è¯â€æ—¶ï¼Œè¯·åˆ©ç”¨è¿™äº›ä¿¡æ¯æ¥ä¸°å¯Œä½ çš„å›ç­”ã€‚";
                
                enabledGlobalBooks.forEach(book => {
                    globalWorldBookContent += `\n\n## ä¹¦å: ${book.name}`;
                    if (book.description) {
                        globalWorldBookContent += `\n${book.description}`;
                    }
                    
                    book.entries.forEach(entry => {
                        if (entry.enabled && entry.content) {
                            const entryName = entry.comment || 'æœªå‘½åæ¡ç›®';
                            const entryKeys = Array.isArray(entry.keys) && entry.keys.length > 0 ? entry.keys.join(', ') : 'æ— ';
                            const entryContent = entry.content;
                            globalWorldBookContent += `\n\n### ${entryName}\n**å…³é”®è¯:** ${entryKeys}\n**å†…å®¹:**\n${entryContent}`;
                        }
                    });
                });
                
                finalSystemPromptParts.push(globalWorldBookContent.trim());
            }

            if (conversation.systemPrompt) {
                finalSystemPromptParts.push(`[Additional Instructions]\n${conversation.systemPrompt}`);
            }
            const finalSystemPrompt = finalSystemPromptParts.join('\n\n---\n\n').trim();
            if (finalSystemPrompt) {
                contextTimeline.push({ type: 'main_system_prompt', role: 'system', content: finalSystemPrompt });
            }

            const historyWithContext = (state.settings.contextCount > 0)
                ? conversation.history.slice(-state.settings.contextCount)
                : [...conversation.history];
            historyWithContext.forEach(msg => contextTimeline.push({ type: 'chat_history', ...msg }));

            const enabledPrompts = prompts.filter(p => p.enabled).sort((a, b) => (a.injection_order || 0) - (b.injection_order || 0));

            enabledPrompts.forEach(prompt => {
                const newPrompt = { role: prompt.role, content: prompt.content };
                const pos = prompt.injection_position;
                const depth = prompt.injection_depth;

                switch (pos) {
                    case 0:
                    case 1: 
                        {
                            const firstSystemPromptIndex = contextTimeline.findIndex(m => m.type === 'main_system_prompt');
                            const injectionIndex = (firstSystemPromptIndex !== -1) ? firstSystemPromptIndex + 1 : 0;
                            contextTimeline.splice(injectionIndex, 0, newPrompt);
                            break;
                        }
                    case 2:
                        {
                            const historyStartIndex = contextTimeline.findIndex(m => m.type === 'chat_history');
                            if (historyStartIndex !== -1) {
                                const insertionIndex = Math.max(historyStartIndex, contextTimeline.length - depth);
                                contextTimeline.splice(insertionIndex, 0, newPrompt);
                            } else {
                                const lastSystemPromptIndex = findLastIndex(contextTimeline, m => m.role === 'system');
                                contextTimeline.splice(lastSystemPromptIndex + 1, 0, newPrompt);
                            }
                            break;
                        }
                }
            });
            
            const tempVars = {};
            const variableParser = (text) => {
                 if (typeof text !== 'string') return text;
                text = text.replace(/{{setvar::(.*?)::(.*?)}}/gs, (_, key, value) => { tempVars[key.trim()] = value.trim(); return ''; });
                text = text.replace(/{{getvar::(.*?)}}/gs, (_, key) => { return tempVars[key.trim()] || ''; });
                const lastUserMsg = conversation.history.findLast(m => m.role === 'user');
                let lastUserMessageText = '';
                if(lastUserMsg) {
                    lastUserMessageText = Array.isArray(lastUserMsg.content) ? (lastUserMsg.content.find(p => p.type === 'text')?.text || '') : lastUserMsg.content;
                }
                return getProcessedText(text).replace(/{{lastUserMessage}}/g, lastUserMessageText);
            };

            return contextTimeline.map(msg => {
                const { type, model, internal, ...apiMsg } = msg;
                if (typeof apiMsg.content === 'string') {
                    apiMsg.content = variableParser(apiMsg.content);
                } else if (Array.isArray(apiMsg.content)) {
                    apiMsg.content = apiMsg.content.map(part => 
                        part.type === 'text' ? { ...part, text: variableParser(part.text) } : part
                    );
                }
                return apiMsg;
            }).filter(msg => {
                if (typeof msg.content === 'string') return msg.content.trim() !== '';
                if (Array.isArray(msg.content)) return msg.content.some(p => (p.type === 'text' && p.text.trim() !== '') || p.type !== 'text');
                return false;
            });
        };

        function findLastIndex(arr, callback) {
            for (let i = arr.length - 1; i >= 0; i--) {
                if (callback(arr[i], i, arr)) {
                    return i;
                }
            }
            return -1;
        }
        
        const executeApiRequest = async (conversation, assistantMsgIndex, assistantMsgEl) => {
            const provider = state.providers[state.currentProviderIndex];
            state.abortController = new AbortController();
            
            const apiCompliantMessages = buildApiMessages(conversation);
            
            if (apiCompliantMessages.length === 0 || (apiCompliantMessages[apiCompliantMessages.length - 1].role === 'assistant' && !apiCompliantMessages[apiCompliantMessages.length - 1].content)) {
                 throw new Error("æ²¡æœ‰å¯å‘é€çš„æ–‡æœ¬å†…å®¹ï¼Œæˆ–æ¶ˆæ¯æ ¼å¼ä¸æ­£ç¡®ã€‚");
            }

            const endpoint = provider.endpoint || '/chat/completions';
            const apiUrl = provider.url.endsWith('/') ? provider.url.slice(0, -1) : provider.url;
            
            const preset = getCurrentPreset() || getDefaultPreset(); 
            
            const requestBody = {
                model: state.currentModel,
                messages: apiCompliantMessages,
                stream: preset.stream_openai ?? state.settings.stream,
                
                temperature: preset.temperature,
                max_tokens: preset.openai_max_tokens,
                top_p: preset.top_p,
                top_k: preset.top_k > 0 ? preset.top_k : undefined,
                frequency_penalty: preset.frequency_penalty,
                presence_penalty: preset.presence_penalty,
                repetition_penalty: preset.repetition_penalty,
                ...(preset.top_a > 0 && { top_a: preset.top_a }),
                ...(preset.min_p > 0 && { min_p: preset.min_p }),
            };

            if (state.settings.search) {
                requestBody.search_enabled = true; 
            }

            const response = await fetch(apiUrl + endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${provider.key}` },
                body: JSON.stringify(requestBody),
                signal: state.abortController.signal,
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error: ${errorData.error.message}`);
            }

            let finishReason = '';
            if (requestBody.stream) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.substring(6);
                            if (data.trim() === '[DONE]') break;
                            try {
                                const json = JSON.parse(data);
                                if (json.choices[0]?.finish_reason) {
                                    finishReason = json.choices[0].finish_reason;
                                }
                                const content = json.choices[0]?.delta?.content || '';
                                if (content) {
                                    conversation.history[assistantMsgIndex].content += content;
                                    updateMessageContent(assistantMsgEl, conversation.history[assistantMsgIndex].content, 'assistant');
                                    assistantMsgEl.appendChild(assistantMsgEl.cursor);
                                    DOMElements.chatContainer.scrollTop = DOMElements.chatContainer.scrollHeight;
                                }
                            } catch (e) { console.error('Error parsing stream data:', e, 'Data:', data); }
                        }
                    }
                }
            } else {
                const data = await response.json();
                const aiResponse = data.choices[0].message.content;
                finishReason = data.choices[0].finish_reason;
                conversation.history[assistantMsgIndex].content += aiResponse;
            }
            
            return finishReason; 
        };

        const _getAiResponse = async () => {
            const currentConv = getCurrentConversation();
            if (!currentConv) return;
            
            DOMElements.sendButton.innerHTML = '<div class="stop-loader-wrapper"><div class="stop-loader"></div><div class="stop-square"></div></div>';
            DOMElements.sendButton.title = 'åœæ­¢ç”Ÿæˆ';
            DOMElements.sendButton.onclick = () => state.abortController?.abort();
            
            currentConv.history.push({ role: 'assistant', content: '', model: state.currentModel });
            const assistantMsgIndex = currentConv.history.length - 1;
            
            renderChatHistory();
            const assistantMsgDiv = DOMElements.chatContainer.querySelector(`.message[data-message-index="${assistantMsgIndex}"]`);
            const assistantMsgEl = assistantMsgDiv ? assistantMsgDiv.querySelector('.content') : null;
            if(!assistantMsgEl) {
                console.error("Could not find the new assistant message element.");
                currentConv.history.pop(); 
                DOMElements.sendButton.innerHTML = 'â¤';
                DOMElements.sendButton.title = 'å‘é€ (Cmd/Ctrl+Enter)';
                DOMElements.sendButton.onclick = sendMessage;
                return;
            }
            
            const cursor = document.createElement('span');
            cursor.className = 'typing-cursor';
            assistantMsgEl.appendChild(cursor);
            assistantMsgEl.cursor = cursor;

            DOMElements.messageInput.value = '';
            DOMElements.messageInput.style.height = 'auto';
            clearAttachments();

            try {
                const provider = state.providers[state.currentProviderIndex];
                if (!provider || !provider.key || provider.key === 'YOUR_API_KEY_HERE') {
                    throw new Error('æ— æ•ˆçš„APIä¾›åº”å•†æˆ–å¯†é’¥ã€‚è¯·åœ¨è®¾ç½®ä¸­é…ç½®ã€‚');
                }
                
                let finishReason;
                do {
                    finishReason = await executeApiRequest(currentConv, assistantMsgIndex, assistantMsgEl);

                    if (finishReason === 'length') {
                        currentConv.history.push({
                            role: 'user',
                            content: 'Please continue generating the response from where you left off. Do not repeat anything, just provide the continuation.',
                            internal: true
                        });
                    }
                } while (finishReason === 'length');
                
            } catch (error) {
                if (error.name !== 'AbortError') {
                    currentConv.history[assistantMsgIndex].content = `å‘ç”Ÿé”™è¯¯: ${error.message}`;
                } else {
                    currentConv.history[assistantMsgIndex].content += '\n\n[STOPPED_MESSAGE]';
                }
            } finally {
                if(cursor) cursor.remove();
                updateMessageContent(assistantMsgEl, currentConv.history[assistantMsgIndex].content, 'assistant');
                recalculateTotalTokens(); 
                saveState();

                DOMElements.sendButton.innerHTML = 'â¤';
                DOMElements.sendButton.title = 'å‘é€ (Cmd/Ctrl+Enter)';
                DOMElements.sendButton.onclick = sendMessage;
            }
        };
        
        const generateConversationTitle = async (conversation, firstMessage) => {
            if (conversation.isTitleGenerating) return;

            const provider = state.providers[state.currentProviderIndex];
            if (!provider || !provider.key || provider.key === 'YOUR_API_KEY_HERE') {
                return; 
            }
            
            try {
                conversation.isTitleGenerating = true;
                const titlePrompt = `ä¸ºä»¥ä¸‹å¯¹è¯ç”Ÿæˆä¸€ä¸ªä¸è¶…è¿‡10ä¸ªå­—çš„ç®€çŸ­æ ‡é¢˜ï¼Œåªè¿”å›æ ‡é¢˜æœ¬èº«ï¼Œä¸è¦ä»»ä½•å¤šä½™çš„æ–‡å­—æˆ–ç¬¦å·:\n\n"${firstMessage}"`;
                
                const endpoint = provider.endpoint || '/chat/completions';
                const apiUrl = provider.url.endsWith('/') ? provider.url.slice(0, -1) : provider.url;
                
                const response = await fetch(apiUrl + endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${provider.key}` },
                    body: JSON.stringify({
                        model: state.currentModel,
                        messages: [{ role: 'user', content: titlePrompt }],
                        temperature: 0.5,
                        max_tokens: 30,
                        stream: false,
                    }),
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();
                const title = data.choices[0].message.content.trim().replace(/["'â€œâ€ï¼Œã€‚.]/g, ''); 
                if (title) {
                    conversation.title = title;
                    renderConversationsList();
                    renderHeaderTitle();
                    saveState();
                }
            } catch (error) {
                console.error("Failed to generate conversation title:", error);
            } finally {
                conversation.isTitleGenerating = false;
            }
        };

        const sendMessage = async () => {
            const userInput = DOMElements.messageInput.value.trim();
            const currentConv = getCurrentConversation();
            if (!currentConv) return;

            if (!userInput && state.attachedFiles.length === 0) {
                let lastUserMsgIndex = -1;
                for (let i = currentConv.history.length - 1; i >= 0; i--) {
                    if (currentConv.history[i].role === 'user' && !currentConv.history[i].internal) {
                        lastUserMsgIndex = i;
                        break;
                    }
                }

                if (lastUserMsgIndex !== -1) {
                    conv.history.splice(lastUserMsgIndex + 1);
                    renderChatHistory(); 
                    _getAiResponse();
                }
                return;
            }

            const userMessageContent = [];
            state.attachedFiles.forEach(file => {
                if (file.fileType === 'image') userMessageContent.push({ type: 'image_url', image_url: { url: file.content } });
                else if (file.fileType === 'text') userMessageContent.push({ type: 'text_attachment', name: file.name, content: file.content });
            });
            if (userInput) userMessageContent.push({ type: 'text', text: userInput });
            
            const isFirstMessage = currentConv.history.filter(m => !m.internal).length === 0 && userInput;
            
            currentConv.history.push({ role: 'user', content: userMessageContent });
            
            if (isFirstMessage && !currentConv.characterProfile) {
                currentConv.title = userInput.substring(0, 50);
                renderConversationsList(); 
                renderHeaderTitle();
                generateConversationTitle(currentConv, userInput);
            }
            
            renderChatHistory(); 
            _getAiResponse();
        };

        const simpleMarkdown = (text) => {
            text = text || '';
            text = text.replace(/\[STOPPED_MESSAGE\]/g, '<p class="stopped-message">(å·²åœæ­¢)</p>');

            let processedText = text.split('\n').map(line => {
                if (/^\s*["â€œ]/.test(line)) {
                    return '> ' + line;
                }
                return line;
            }).join('\n');

            if (window.marked && window.DOMPurify) {
                return DOMPurify.sanitize(marked.parse(processedText));
            } else {
                console.warn("Marked.js or DOMPurify not loaded. Using basic renderer.");
                return processedText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
            }
        };

        const STATUS_BLOCK_REGEX = /<Status_block>\s*([\s\S]*?)\s*<\/Status_block>/i;
        const STATUS_MAINTEXT_REGEX = /<maintext>\s*([\s\S]*?)\s*<\/maintext>/i;

        function extractStatusBlockSegments(text) {
            if (typeof text !== 'string') return null;
            const statusMatch = text.match(STATUS_BLOCK_REGEX);
            if (!statusMatch) return null;
            const maintextMatch = text.match(STATUS_MAINTEXT_REGEX);
            let remaining = text.replace(statusMatch[0], '');
            if (maintextMatch) {
                remaining = remaining.replace(maintextMatch[0], '');
            }
            return {
                yaml: statusMatch[1].trim(),
                maintext: maintextMatch ? maintextMatch[1].trim() : '',
                remainingText: remaining.trim(),
            };
        }

        function renderStatusBlockInto(contentDiv, payload) {
            const wrapper = document.createElement('div');
            wrapper.className = 'status-block-shell';
            contentDiv.appendChild(wrapper);

            if (!window.jsyaml) {
                wrapper.innerHTML = '<div class="status-block-error">ç¼ºå°‘ js-yaml åº“ï¼Œæ— æ³•è§£æçŠ¶æ€æ ã€‚</div>';
                return;
            }

            let yamlData;
            try {
                yamlData = window.jsyaml.load(payload.yaml);
            } catch (error) {
                wrapper.innerHTML = `<div class="status-block-error">Status_block è§£æå¤±è´¥ï¼š${escapeHtml(error.message)}</div>`;
                return;
            }

            if (!yamlData || typeof yamlData !== 'object') {
                wrapper.innerHTML = '<div class="status-block-error">Status_block æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼å¼‚å¸¸ã€‚</div>';
                return;
            }

            const rootKey = Object.keys(yamlData)[0];
            const rootData = rootKey ? yamlData[rootKey] : yamlData;
            if (!rootData || typeof rootData !== 'object') {
                wrapper.innerHTML = '<div class="status-block-error">æœªæ‰¾åˆ°æœ‰æ•ˆçš„çŠ¶æ€æ å­—æ®µã€‚</div>';
                return;
            }

            const header = document.createElement('div');
            header.className = 'status-block-header';
            header.appendChild(createStatusHeaderPill('ğŸ“ åœ°ç‚¹', readStatusField(rootData, ['åœ°ç‚¹', 'ä½ç½®', 'location', 'place']) || 'æœªçŸ¥åœ°ç‚¹'));
            header.appendChild(createStatusHeaderPill('â° æ—¶é—´', readStatusField(rootData, ['æ—¥æœŸ', 'æ—¶é—´', 'datetime', 'time']) || 'æœªçŸ¥æ—¶é—´'));

            const actionBlockKey = findStatusFieldByKeywords(rootData, ['è¡ŒåŠ¨', 'é€‰é¡¹', 'action', 'option']);
            const actionBlock = actionBlockKey ? rootData[actionBlockKey] : null;
            const ownerName = actionBlock ? readStatusField(actionBlock, ['åå­—', 'å§“å', 'æ‰€æœ‰è€…', 'owner', 'name']) : '';
            header.appendChild(createStatusHeaderPill('ğŸ§­ å½“å‰æ‰§è¡Œè€…', ownerName || 'æœªçŸ¥'));
            wrapper.appendChild(header);

            if (payload.maintext) {
                const mainSection = document.createElement('div');
                mainSection.className = 'status-block-section';
                const heading = document.createElement('h3');
                heading.textContent = 'å‰§æƒ…æ­£æ–‡';
                mainSection.appendChild(heading);

                const maintextBody = document.createElement('div');
                maintextBody.className = 'status-block-maintext';
                const paragraphs = payload.maintext.split(/\n\s*\n/);
                paragraphs.forEach(paragraph => {
                    const trimmed = paragraph.trim();
                    if (!trimmed) return;
                    const p = document.createElement('p');
                    p.innerHTML = escapeHtml(trimmed).replace(/\n/g, '<br>');
                    maintextBody.appendChild(p);
                });
                if (!maintextBody.childNodes.length) {
                    const p = document.createElement('p');
                    p.textContent = payload.maintext.trim();
                    maintextBody.appendChild(p);
                }
                mainSection.appendChild(maintextBody);
                wrapper.appendChild(mainSection);
            }

            const charSection = document.createElement('div');
            charSection.className = 'status-block-section';
            const charHeading = document.createElement('h3');
            charHeading.textContent = 'è§’è‰²çŠ¶æ€';
            charSection.appendChild(charHeading);
            const charGrid = document.createElement('div');
            charGrid.className = 'status-character-grid';
            const userListKey = findStatusFieldByKeywords(rootData, ['ç”¨æˆ·åˆ—è¡¨', 'è§’è‰²åˆ—è¡¨', 'ç”¨æˆ·', 'è§’è‰²', 'character', 'user']);
            const characters = userListKey ? rootData[userListKey] : null;
            if (Array.isArray(characters) && characters.length) {
                characters.forEach(entry => {
                    const normalized = normalizeStatusCharacter(entry);
                    const card = document.createElement('div');
                    card.className = 'status-character-card';
                    const title = document.createElement('h4');
                    title.textContent = normalized.name;
                    card.appendChild(title);
                    const list = document.createElement('ul');
                    if (!normalized.attributes.length) {
                        const li = document.createElement('li');
                        const span = document.createElement('span');
                        span.textContent = 'è¯´æ˜';
                        const p = document.createElement('p');
                        p.textContent = 'æ— è¯¦ç»†ä¿¡æ¯';
                        li.appendChild(span);
                        li.appendChild(p);
                        list.appendChild(li);
                    } else {
                        normalized.attributes.forEach(attr => {
                            const li = document.createElement('li');
                            const span = document.createElement('span');
                            span.textContent = attr.label;
                            const p = document.createElement('p');
                            p.textContent = attr.value;
                            li.appendChild(span);
                            li.appendChild(p);
                            list.appendChild(li);
                        });
                    }
                    card.appendChild(list);
                    charGrid.appendChild(card);
                });
            } else {
                const empty = document.createElement('div');
                empty.className = 'status-empty';
                empty.textContent = 'æ²¡æœ‰è§’è‰²æ•°æ®';
                charGrid.appendChild(empty);
            }
            charSection.appendChild(charGrid);
            wrapper.appendChild(charSection);

            const actionsSection = document.createElement('div');
            actionsSection.className = 'status-block-section';
            const actionsHeading = document.createElement('h3');
            actionsHeading.textContent = 'è¡ŒåŠ¨é€‰é¡¹';
            actionsSection.appendChild(actionsHeading);
            const optionsField = actionBlock ? findStatusFieldByKeywords(actionBlock, ['é€‰é¡¹', 'options', 'choices']) : null;
            const options = optionsField ? actionBlock[optionsField] : null;
            if (Array.isArray(options) && options.length) {
                const list = document.createElement('ul');
                list.className = 'status-actions';
                options.forEach((optionText, index) => {
                    const li = document.createElement('li');
                    li.textContent = optionText || `é€‰é¡¹ ${index + 1}`;
                    list.appendChild(li);
                });
                actionsSection.appendChild(list);
            } else {
                const empty = document.createElement('div');
                empty.className = 'status-empty';
                empty.textContent = 'æ²¡æœ‰å¯ç”¨é€‰é¡¹';
                actionsSection.appendChild(empty);
            }
            wrapper.appendChild(actionsSection);
        }

        function createStatusHeaderPill(label, value) {
            const pill = document.createElement('div');
            pill.className = 'status-pill';
            const span = document.createElement('span');
            span.textContent = label;
            const strong = document.createElement('strong');
            strong.textContent = value || 'æœªçŸ¥';
            pill.appendChild(span);
            pill.appendChild(strong);
            return pill;
        }

        function findStatusFieldByKeywords(source, keywords) {
            if (!source || typeof source !== 'object') return null;
            const keys = Object.keys(source);
            for (const key of keys) {
                const lower = key.toLowerCase();
                if (keywords.some(word => lower.includes(word.toLowerCase()))) {
                    return key;
                }
            }
            return null;
        }

        function readStatusField(source, keywords) {
            const key = findStatusFieldByKeywords(source, keywords);
            if (!key) return '';
            const value = source[key];
            if (typeof value === 'string') return value.trim();
            if (typeof value === 'number' || typeof value === 'boolean') return String(value);
            return formatStatusValue(value);
        }

        function normalizeStatusCharacter(entry) {
            if (!entry) {
                return { name: 'æœªçŸ¥è§’è‰²', attributes: [] };
            }

            let payload = entry;
            if (typeof entry === 'object' && entry !== null) {
                const nestedKey = findStatusFieldByKeywords(entry, ['ç”¨æˆ·', 'è§’è‰²', 'äººç‰©', 'character', 'person']);
                if (nestedKey && typeof entry[nestedKey] === 'object') {
                    payload = entry[nestedKey];
                }
            } else {
                return { name: String(entry), attributes: [] };
            }

            if (!payload || typeof payload !== 'object') {
                return { name: 'æœªçŸ¥è§’è‰²', attributes: [] };
            }

            const name = readStatusField(payload, ['åå­—', 'å§“å', 'åç§°', 'name']) || 'æœªçŸ¥è§’è‰²';
            const attributes = [];
            Object.keys(payload).forEach(key => {
                const lower = key.toLowerCase();
                if (lower.includes('åå­—') || lower === 'name') return;
                const normalizedValue = formatStatusValue(payload[key]);
                if (normalizedValue) {
                    attributes.push({ label: key, value: normalizedValue });
                }
            });
            return { name, attributes };
        }

        function formatStatusValue(value) {
            if (value === null || value === undefined) return '';
            if (typeof value === 'string') return value.trim();
            if (typeof value === 'number' || typeof value === 'boolean') return String(value);
            if (Array.isArray(value)) {
                return value
                    .map(item => {
                        if (item === null || item === undefined) return '';
                        if (typeof item === 'object') {
                            const subKey = Object.keys(item)[0];
                            if (subKey) {
                                return `${subKey}: ${formatStatusValue(item[subKey])}`;
                            }
                            return formatStatusValue(Object.values(item)[0]);
                        }
                        return formatStatusValue(item);
                    })
                    .filter(Boolean)
                    .join('ï¼›');
            }
            if (typeof value === 'object') {
                return Object.entries(value)
                    .map(([key, val]) => `${key}: ${formatStatusValue(val)}`)
                    .filter(Boolean)
                    .join('ï¼›');
            }
            return '';
        }

        function escapeHtml(text) {
            if (typeof text !== 'string') return '';
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        const enhanceCodeBlocks = (container) => {
            container.querySelectorAll('pre').forEach(pre => {
                if (pre.querySelector('.code-header')) return;
                const code = pre.querySelector('code');
                if (!code) return;
                const language = (code.className.match(/language-(\w+)/) || [])[1] || 'plaintext';
                
                                // å¦‚æœä»£ç å—å†…å®¹ä¸ºç©ºï¼Œå°±ä¸æ˜¾ç¤ºè¿™ä¸ªä»£ç å—ï¼ˆç”¨äºéšè—ä¸€äº›è°ƒè¯•äº§ç”Ÿçš„ç©ºå—ï¼‰
                if (!code.textContent || !code.textContent.trim()) {
                    pre.remove();
                    return;
                }

                const header = document.createElement('div'); header.className = 'code-header';
                const langSpan = document.createElement('span'); langSpan.className = 'lang'; langSpan.textContent = language;
                const buttonsDiv = document.createElement('div'); buttonsDiv.className = 'code-buttons';
                const collapseBtn = document.createElement('button'); collapseBtn.textContent = 'â–¼'; collapseBtn.title = 'æŠ˜å /å±•å¼€';
                collapseBtn.onclick = () => { pre.classList.toggle('collapsed'); collapseBtn.textContent = pre.classList.contains('collapsed') ? 'â–¶' : 'â–¼'; };
                const copyBtn = document.createElement('button'); copyBtn.textContent = 'ğŸ“‹'; copyBtn.title = 'å¤åˆ¶';
                copyBtn.onclick = () => navigator.clipboard.writeText(code.textContent).then(() => { copyBtn.textContent = 'âœ…'; setTimeout(() => copyBtn.textContent = 'ğŸ“‹', 2000); });
                const downloadBtn = document.createElement('button'); downloadBtn.textContent = 'ğŸ’¾'; downloadBtn.title = 'ä¸‹è½½';
                downloadBtn.onclick = () => {
                    const blob = new Blob([code.textContent], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob); const a = document.createElement('a');
                    a.href = url; a.download = `code.${language === 'plaintext' ? 'txt' : language}`;
                    a.click(); URL.revokeObjectURL(url); a.remove();
                };
                buttonsDiv.appendChild(collapseBtn); buttonsDiv.appendChild(copyBtn); buttonsDiv.appendChild(downloadBtn);
                header.appendChild(langSpan); header.appendChild(buttonsDiv);
                pre.insertBefore(header, code);
                if (window.Prism) {
                    Prism.highlightElement(code);
                }
            });
        };
        
        const handleFiles = (files) => {
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.type.startsWith('image/')) {
                        state.attachedFiles.push({ name: file.name, type: file.type, fileType: 'image', content: e.target.result });
                    } else {
                        state.attachedFiles.push({ name: file.name, type: file.type, fileType: 'text', content: e.target.result });
                    }
                    renderAttachmentPreviews();
                };
                
                if (file.type.startsWith('image/')) {
                    reader.readAsDataURL(file);
                } else {
                    reader.readAsText(file);
                }
            }
        };

        const renderAttachmentPreviews = () => {
            DOMElements.attachmentPreviews.innerHTML = '';
            state.attachedFiles.forEach((file, index) => {
                const previewDiv = document.createElement('div'); previewDiv.className = 'attachment-preview';
                if (file.fileType === 'image') {
                    previewDiv.innerHTML = `<img src="${file.content}" alt="${file.name}" loading="lazy">`;
                } else { 
                    previewDiv.innerHTML = `<span>ğŸ“ ${file.name}</span>`; 
                }
                const removeBtn = document.createElement('button'); removeBtn.className = 'remove-attachment';
                removeBtn.innerHTML = '&times;'; removeBtn.onclick = () => removeAttachment(index);
                previewDiv.appendChild(removeBtn); DOMElements.attachmentPreviews.appendChild(previewDiv);
            });
        };
        const removeAttachment = (index) => { state.attachedFiles.splice(index, 1); renderAttachmentPreviews(); };
        const clearAttachments = () => { state.attachedFiles = []; renderAttachmentPreviews(); };
        const openSettingsModal = () => {
            renderSettings();
            DOMElements.settingsModal.style.display = 'flex';
            openTab(null, 'profile-tab', DOMElements.settingsModal);
        };
        const closeSettingsModal = () => DOMElements.settingsModal.style.display = 'none';
        
        const handleAvatarChange = (e, callback) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                DOMElements.imageToCrop.src = event.target.result;
                DOMElements.cropperModal.style.display = 'flex';
                
                if (cropper) cropper.destroy();
                
                cropper = new Cropper(DOMElements.imageToCrop, {
                    aspectRatio: 1, viewMode: 1, background: false, autoCropArea: 0.8,
                    movable: false, zoomable: false, rotatable: false, scalable: false,
                    cropBoxResizable: true,
                });
                currentCroppingCallback = callback;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        };

        const clearProviderForm = () => {
            DOMElements.providerId.value = ''; DOMElements.providerName.value = '';
            DOMElements.apiUrl.value = ''; DOMElements.apiKey.value = ''; DOMElements.modelNames.value = '';
            DOMElements.apiEndpoint.value = '';
        };
        const saveProvider = () => {
            const id = DOMElements.providerId.value;
            const provider = {
                name: DOMElements.providerName.value.trim(), url: DOMElements.apiUrl.value.trim(),
                key: DOMElements.apiKey.value.trim(), models: DOMElements.modelNames.value.trim(),
                endpoint: DOMElements.apiEndpoint.value.trim()
            };
            if (!provider.name || !provider.key || !provider.models) { alert('åç§°, APIå¯†é’¥ å’Œ æ¨¡å‹åç§°ä¸ºå¿…å¡«é¡¹ã€‚'); return; }
            if (id) {
                const index = state.providers.findIndex(p => p.id == id);
                if (index > -1) state.providers[index] = { ...state.providers[index], ...provider };
            } else state.providers.push({ id: Date.now(), ...provider });
            clearProviderForm(); renderProviders(); saveState();
        };
        
        const toggleMobileMenu = (event) => {
            event.stopPropagation();
            DOMElements.mobileActionsMenu.classList.toggle('visible');
        };

        const closeMobileMenu = () => {
            if (DOMElements.mobileActionsMenu.classList.contains('visible')) {
                DOMElements.mobileActionsMenu.classList.remove('visible');
            }
        };


        window.app = {
            editProvider: (index) => {
                const provider = state.providers[index];
                DOMElements.providerId.value = provider.id; DOMElements.providerName.value = provider.name;
                DOMElements.apiUrl.value = provider.url; DOMElements.apiKey.value = provider.key;
                DOMElements.modelNames.value = provider.models;
                DOMElements.apiEndpoint.value = provider.endpoint || ''; 
                closeMobileMenu(); 
                openSettingsModal();
                openTab(null, 'providers-tab', DOMElements.settingsModal);
            },
            deleteProvider: (index) => {
                if (confirm(`ç¡®å®šè¦åˆ é™¤ä¾›åº”å•† "${state.providers[index].name}" å—ï¼Ÿ`)) {
                    state.providers.splice(index, 1);
                    if (state.currentProviderIndex >= index) state.currentProviderIndex = Math.max(0, state.currentProviderIndex - 1);
                    renderProviders(); saveState();
                }
            },
            resendMessage: (index) => {
                const conv = getCurrentConversation();
                if (!conv || !conv.history[index] || conv.history[index].role !== 'user') return;

                if (confirm('è¿™å°†ç§»é™¤æ­¤æ¶ˆæ¯ä¹‹åçš„æ‰€æœ‰å¯¹è¯å¹¶é‡æ–°ç”Ÿæˆå›å¤ï¼Œç¡®å®šå—ï¼Ÿ')) {
                    conv.history.splice(index + 1);
                    _getAiResponse();
                }
            },
            regenerateResponse: (index) => {
                const conv = getCurrentConversation();
                if (!conv || !conv.history[index] || conv.history[index].role !== 'assistant') return;

                if (confirm('è¿™å°†ç§»é™¤æ­¤AIå›å¤ä»¥åŠä¹‹åçš„æ‰€æœ‰å¯¹è¯ï¼Œå¹¶é‡æ–°ç”Ÿæˆã€‚ç¡®å®šå—ï¼Ÿ')) {
                    conv.history.splice(index);
                    renderChatHistory();
                    _getAiResponse();
                }
            },
            forkConversation: (index) => {
                const currentConv = getCurrentConversation();
                if (!currentConv) return;
                
                const forkedHistory = currentConv.history.slice(0, index + 1);
                
                const newConversation = {
                    id: Date.now(),
                    title: `${currentConv.title} (åˆ†æ”¯)`,
                    history: forkedHistory,
                    tokenCount: 0, 
                    systemPrompt: currentConv.systemPrompt,
                    characterProfile: currentConv.characterProfile ? JSON.parse(JSON.stringify(currentConv.characterProfile)) : null
                };
                
                state.conversations.push(newConversation);
                switchConversation(newConversation.id);
            },
            editMessage: (index) => {
                const conv = getCurrentConversation();
                const message = conv.history[index];
                const messageDiv = DOMElements.chatContainer.querySelector(`.message[data-message-index="${index}"]`);
                if (!messageDiv) return;

                const contentDiv = messageDiv.querySelector('.content');
                const attachmentIndicesToDelete = new Set();
                let originalText = '';
                let attachmentsHtml = '<div class="edit-attachments-container">';

                if (Array.isArray(message.content)) {
                    message.content.forEach((part, partIndex) => {
                        if (part.type === 'text') {
                            originalText += (part.text || '') + '\n';
                        } else {
                            let attachmentPreview = '';
                            if (part.type === 'image_url') {
                                attachmentPreview = `<img src="${part.image_url.url}" alt="image attachment" loading="lazy">`;
                            } else if (part.type === 'text_attachment') {
                                attachmentPreview = `<span>ğŸ“ ${part.name}</span>`;
                            }
                            attachmentsHtml += `
                                <div class="attachment-preview" data-part-index="${partIndex}">
                                    ${attachmentPreview}
                                    <button class="remove-attachment" data-part-index="${partIndex}">&times;</button>
                                </div>`;
                        }
                    });
                    originalText = originalText.trim();
                } else {
                    originalText = message.content || '';
                }
                attachmentsHtml += '</div>';

                contentDiv.innerHTML = `${attachmentsHtml}<textarea class="editing-textarea">${originalText}</textarea><div class="edit-controls"><button class="save">ä¿å­˜</button><button class="cancel">å–æ¶ˆ</button></div>`;
                
                const textarea = contentDiv.querySelector('textarea');
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
                textarea.focus();

                contentDiv.querySelectorAll('.remove-attachment').forEach(button => {
                    button.onclick = () => {
                        const partIndex = parseInt(button.dataset.partIndex, 10);
                        attachmentIndicesToDelete.add(partIndex);
                        button.closest('.attachment-preview').style.display = 'none';
                    };
                });

                contentDiv.querySelector('.save').onclick = () => window.app.saveMessageEdit(index, textarea.value, attachmentIndicesToDelete);
                contentDiv.querySelector('.cancel').onclick = () => renderChatHistory();
            },
            copyMessage: (event, index) => {
                const button = event.currentTarget;
                if (!button) return;

                const conv = getCurrentConversation();
                if (!conv) return;
                const message = conv.history[index];
                if (!message) return;

                let textToCopy = '';
                if (typeof message.content === 'string') {
                    textToCopy = message.content;
                } else if (Array.isArray(message.content)) {
                    textToCopy = message.content
                        .filter(part => part.type === 'text')
                        .map(part => part.text)
                        .join('\n');
                }

                if (!textToCopy.trim()) {
                    return;
                }

                if (!navigator.clipboard) {
                    console.error('Clipboard API not available. Requires a secure context (HTTPS).');
                    const originalContent = button.innerHTML;
                    button.innerHTML = 'âŒ';
                    setTimeout(() => { button.innerHTML = originalContent; }, 2000);
                    return;
                }

                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalContent = button.innerHTML;
                    const originalColor = button.style.color;
                    button.innerHTML = 'âœ…';
                    button.style.color = 'var(--primary-color)';
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                        button.style.color = originalColor;
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    const originalContent = button.innerHTML;
                    button.innerHTML = 'âŒ';
                    setTimeout(() => {
                        button.innerHTML = originalContent;
                    }, 2000);
                });
            },
            saveMessageEdit: (index, newText, indicesToDelete) => {
                const conv = getCurrentConversation();
                const message = conv.history[index];

                const oldContentIsArray = Array.isArray(message.content);
                const oldContentParts = oldContentIsArray ? [...message.content] : [{type: 'text', text: message.content}];
                
                const newContentParts = oldContentParts.filter((part, partIndex) => !indicesToDelete.has(partIndex));

                const textPartIndex = newContentParts.findIndex(p => p.type === 'text');
                if (newText.trim()) {
                    if (textPartIndex > -1) {
                        newContentParts[textPartIndex].text = newText;
                    } else {
                        newContentParts.push({ type: 'text', text: newText });
                    }
                } else if (textPartIndex > -1) { 
                    newContentParts.splice(textPartIndex, 1);
                }

                if (newContentParts.length === 0) {
                    message.content = "";
                } else if (newContentParts.length === 1 && newContentParts[0].type === 'text') {
                    message.content = newContentParts[0].text;
                } else {
                    message.content = newContentParts;
                }
                
                renderChatHistory(); 
                saveState();
            },
            deleteMessage: (index) => {
                if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ')) {
                    const conv = getCurrentConversation(); conv.history.splice(index, 1);
                    renderChatHistory();
                    saveState();
                }
            },
            deleteConversation: (id) => {
                const convToDelete = state.conversations.find(c => c.id === id); if (!convToDelete) return;
                if (confirm(`ç¡®å®šè¦åˆ é™¤è¯é¢˜ "${convToDelete.title}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                    state.conversations = state.conversations.filter(c => c.id !== id);
                    if (state.currentConversationId === id) {
                        if (state.conversations.length > 0) state.currentConversationId = state.conversations.sort((a,b) => b.id - a.id)[0].id;
                        else state.currentConversationId = null;
                    }
                    if (state.conversations.length === 0) createNewConversation();
                    else { 
                        DOMElements.globalSearchInput.value = '';
                        renderAll(); 
                        saveState(); 
                    }
                }         
            },
            // START: New Global World Book Functions
            openGlobalWorldBookEditor: (bookId) => openGlobalWorldBookEditor(bookId),
            deleteGlobalWorldBook: (bookId) => {
                const book = state.globalWorldBooks.find(b => b.id === bookId);
                if (!book) return;
                if (confirm(`ç¡®å®šè¦åˆ é™¤ä¸–ç•Œä¹¦ "${book.name}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                    state.globalWorldBooks = state.globalWorldBooks.filter(b => b.id !== bookId);
                    saveState();
                    renderGlobalWorldBooksList();
                }
            },
            toggleGlobalWorldBook: (bookId) => {
                const book = state.globalWorldBooks.find(b => b.id === bookId);
                if (book) {
                    book.enabled = !book.enabled;
                    saveState();
                }
            },

            switchGreeting: (index) => {
        const conv = getCurrentConversation();
        if (!conv || index !== 0 || !conv.characterProfile) return;
        
        const card = state.characterCards.find(c => c.id === conv.characterProfile.cardId);
        if (!card) return;
        
        const altGreetings = card.cardData.alternate_greetings || [];
        if (altGreetings.length === 0) return;
        
        // ğŸ”§ ä¿®æ­£ï¼šåˆå§‹åŒ–æ—¶è®¾ä¸º 0ï¼ˆè¡¨ç¤ºå½“å‰æ˜¾ç¤ºçš„æ˜¯ first_mesï¼‰
        if (conv.currentGreetingIndex === undefined) {
            conv.currentGreetingIndex = 0;
        }
        
        // ğŸ”§ ä¿®æ­£ï¼šç›´æ¥é€’å¢ï¼Œå¾ªç¯èŒƒå›´æ˜¯ 0 åˆ° altGreetings.length
        conv.currentGreetingIndex = (conv.currentGreetingIndex + 1) % (altGreetings.length + 1);
        
        // æ›´æ–°æ¶ˆæ¯å†…å®¹
        if (conv.currentGreetingIndex === 0) {
            // ç´¢å¼• 0ï¼šé»˜è®¤é—®å€™è¯­
            conv.history[0].content = getProcessedText(card.cardData.first_mes);
        } else {
            // ç´¢å¼• 1~Nï¼šå¤‡é€‰é—®å€™è¯­ï¼ˆaltGreetings[0] ~ altGreetings[N-1]ï¼‰
            const greetingText = altGreetings[conv.currentGreetingIndex - 1];
            conv.history[0].content = getProcessedText(greetingText);
        }
        
        // é‡æ–°æ¸²æŸ“èŠå¤©å†å²
        renderChatHistory();
        saveState();
    }
            // END: New Global World Book Functions
        };

        // --- START: Global World Book UI Functions ---
        const renderWorldBookEditorEntries = (container, entries) => {
            container.innerHTML = '';
            (entries || []).forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'world-book-entry';
                entryDiv.dataset.index = index;
                entryDiv.innerHTML = `
                    <div class="world-book-header">
                        <h4>æ¡ç›® ${index + 1}</h4>
                        <button class="btn-secondary remove-wb-entry" style="padding: 5px;">- åˆ é™¤</button>
                    </div>
                    <div class="form-group">
                        <label>åç§° (Comment)</label>
                        <input type="text" class="form-control" data-field="comment" value="${entry.comment || ''}">
                    </div>
                    <div class="form-group">
                        <label>å…³é”®è¯ (Keys)</label>
                        <input type="text" class="form-control" data-field="keys" value="${(entry.keys || []).join(', ')}">
                    </div>
                    <div class="form-group">
                        <label>å†…å®¹</label>
                        <textarea class="form-control" data-field="content" rows="4">${entry.content || ''}</textarea>
                    </div>
                    <div class="toggle-switch-group">
                        <label class="toggle-switch">
                            <input type="checkbox" data-field="enabled" ${entry.enabled !== false ? 'checked' : ''}> å¯ç”¨
                        </label>
                    </div>
                `;
                container.appendChild(entryDiv);
            });
        };
        const renderGlobalWorldBooksList = () => {
            const container = DOMElements.globalWorldBooksListContainer;
            container.innerHTML = '';
            if (state.globalWorldBooks.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: var(--text-color-muted);">æ²¡æœ‰å…¨å±€ä¸–ç•Œä¹¦ã€‚è¯·æ–°å»ºæˆ–å¯¼å…¥ä¸€ä¸ªã€‚</p>';
                return;
            }

            state.globalWorldBooks.forEach(book => {
                const bookDiv = document.createElement('div');
                bookDiv.className = 'world-book-entry'; // Reuse style
                bookDiv.style.padding = '10px 15px';
                bookDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex-grow: 1;">
                            <h4 style="margin: 0 0 5px 0;">${book.name}</h4>
                            <p style="font-size: 0.85em; margin: 0; color: var(--text-color-muted);">${book.description || 'æ— æè¿°'}</p>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px; flex-shrink: 0;">
                            <label class="toggle-switch" title="å¯ç”¨/ç¦ç”¨æ­¤ä¸–ç•Œä¹¦">
                                <input type="checkbox" onchange="window.app.toggleGlobalWorldBook('${book.id}')" ${book.enabled ? 'checked' : ''}>
                                <span>å¯ç”¨</span>
                            </label>
                            <button class="btn-secondary" onclick="window.app.openGlobalWorldBookEditor('${book.id}')">ç¼–è¾‘</button>
                            <button class="btn-secondary" style="background-color: #e06c75; color: white;" onclick="window.app.deleteGlobalWorldBook('${book.id}')">åˆ é™¤</button>
                        </div>
                    </div>
                `;
                container.appendChild(bookDiv);
            });
        };

        const openGlobalWorldBookEditor = (bookId = null) => {
            if (bookId) {
                const book = state.globalWorldBooks.find(b => b.id === bookId);
                if (!book) {
                    alert('é”™è¯¯ï¼šæ‰¾ä¸åˆ°ä¸–ç•Œä¹¦ã€‚');
                    return;
                }
                DOMElements.editingGlobalBookId.value = book.id;
                DOMElements.globalBookEditorTitle.textContent = `ç¼–è¾‘ä¸–ç•Œä¹¦: ${book.name}`;
                DOMElements.globalBookEditName.value = book.name;
                DOMElements.globalBookEditDesc.value = book.description || '';
                renderWorldBookEditorEntries(DOMElements.globalBookEditEntriesContainer, book.entries);
            } else {
                DOMElements.editingGlobalBookId.value = '';
                DOMElements.globalBookEditorTitle.textContent = 'æ–°å»ºä¸–ç•Œä¹¦';
                DOMElements.globalBookEditName.value = '';
                DOMElements.globalBookEditDesc.value = '';
                renderWorldBookEditorEntries(DOMElements.globalBookEditEntriesContainer, []);
            }
            DOMElements.globalWorldBookEditorModal.style.display = 'flex';
        };

        const closeGlobalWorldBookEditor = () => {
            DOMElements.globalWorldBookEditorModal.style.display = 'none';
        };

        const saveGlobalWorldBook = () => {
            const bookId = DOMElements.editingGlobalBookId.value;
            const bookName = DOMElements.globalBookEditName.value.trim();
            if (!bookName) {
                alert('ä¹¦åä¸èƒ½ä¸ºç©ºã€‚');
                return;
            }

            const entries = [];
            DOMElements.globalBookEditEntriesContainer.querySelectorAll('.world-book-entry').forEach(entryDiv => {
                entries.push({
                    comment: entryDiv.querySelector('[data-field="comment"]').value,
                    keys: entryDiv.querySelector('[data-field="keys"]').value.split(',').map(t => t.trim()).filter(Boolean),
                    content: entryDiv.querySelector('[data-field="content"]').value,
                    enabled: entryDiv.querySelector('[data-field="enabled"]').checked
                });
            });

            if (bookId) {
                const bookIndex = state.globalWorldBooks.findIndex(b => b.id === bookId);
                if (bookIndex > -1) {
                    state.globalWorldBooks[bookIndex].name = bookName;
                    state.globalWorldBooks[bookIndex].description = DOMElements.globalBookEditDesc.value;
                    state.globalWorldBooks[bookIndex].entries = entries;
                }
            } else {
                state.globalWorldBooks.push({
                    id: `wb-${Date.now()}`,
                    name: bookName,
                    description: DOMElements.globalBookEditDesc.value,
                    enabled: true,
                    entries: entries
                });
            }

            saveState();
            renderGlobalWorldBooksList();
            closeGlobalWorldBookEditor();
        };

        // --- END: Global World Book UI Functions ---

        // --- START: Character Card Handlers ---

        const openCharacterSelectionModal = () => {
            renderCharacterCards();
            DOMElements.characterSelectionModal.style.display = 'flex';
        };

        const closeCharacterSelectionModal = () => {
            DOMElements.characterSelectionModal.style.display = 'none';
        };
        
        const renderCharacterCards = () => {
            const gallery = DOMElements.characterGallery;
            gallery.querySelectorAll('.character-card').forEach(cardElement => cardElement.remove());
            
            state.characterCards.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'character-card';
                cardDiv.dataset.id = card.id;
                cardDiv.onclick = (e) => {
                    if (!e.target.closest('.character-card-actions')) {
                        startChatWithCharacter(card.id);
                    }
                };
                
                cardDiv.innerHTML = `
                    <img src="" alt="${card.cardData.name}" loading="lazy">
                    <div class="character-card-name">${card.cardData.name || 'æœªå‘½å'}</div>
                    <div class="character-card-actions">
                        <button class="edit-char-btn" title="ç¼–è¾‘è§’è‰²">âœï¸</button>
                        <button class="delete-char-btn" title="åˆ é™¤è§’è‰²">ğŸ—‘ï¸</button>
                    </div>
                `;
                
                const imgElement = cardDiv.querySelector('img');
                ImageDB.getImage(card.id)
                    .then(imageDataUrl => {
                        if (imageDataUrl) {
                            imgElement.src = imageDataUrl;
                        } else {
                            console.warn(`åœ¨æ•°æ®åº“ä¸­æ‰¾ä¸åˆ°å¡ç‰‡ID ${card.id} å¯¹åº”çš„å›¾ç‰‡`);
                            imgElement.alt = "å›¾ç‰‡ä¸¢å¤±";
                        }
                    })
                    .catch(error => console.error("ä»æ•°æ®åº“åŠ è½½å›¾ç‰‡å¤±è´¥:", error));

                cardDiv.querySelector('.edit-char-btn').onclick = (e) => {
                    e.stopPropagation();
                    openCharacterEditor(card.id);
                };
                cardDiv.querySelector('.delete-char-btn').onclick = (e) => {
                    e.stopPropagation();
                    deleteCharacterCard(card.id);
                };

                gallery.insertBefore(cardDiv, gallery.lastChild);
            });
        };

        const handleCharacterCardImport = (file) => {
            if (!file) return;

            const fileReader = new FileReader();
            fileReader.onload = async (e) => {
                const imageDataUrl = e.target.result;
                try {
                    const buffer = await file.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    if (!isValidPNG(bytes)) throw new Error('æ–‡ä»¶ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„PNGå›¾ç‰‡ã€‚');

                    let cardDataRaw = extractChunkData(bytes, 'chara');
                    if (!cardDataRaw) throw new Error('åœ¨PNGæ–‡ä»¶ä¸­æœªæ‰¾åˆ°SillyTavernè§’è‰²æ•°æ®ã€‚');
                    
                    const parsedJson = JSON.parse(decodeSafeBase64(cardDataRaw));
                    const charData = parsedJson.data || parsedJson; // Handle both wrapper formats
                    if (!charData) throw new Error('è§’è‰²æ•°æ®æ ¼å¼ä¸æ­£ç¡®ã€‚');

                    const newCard = {
                        id: Date.now(),
                        cardData: charData
                    };
                    
                    await ImageDB.addImage(newCard.id, imageDataUrl);

                    state.characterCards.push(newCard);
                    saveState();
                    renderCharacterCards();
                    alert(`è§’è‰² "${charData.name}" å·²æˆåŠŸå¯¼å…¥ï¼`);

                } catch (error) {
                    console.error('å¯¼å…¥è§’è‰²å¡å¤±è´¥:', error);
                    alert(`å¯¼å…¥è§’è‰²å¡å¤±è´¥: ${error.message}`);
                }
            };
            fileReader.readAsDataURL(file);
        };
        
        const buildSystemPromptFromCard = (cardData) => {
            let systemPrompt = `ä½ ç°åœ¨æ­£åœ¨æ‰®æ¼”ä¸€ä¸ªè§’è‰²ã€‚è¯·ä¸¥æ ¼éµå®ˆå¹¶æ²‰æµ¸åœ¨ä»¥ä¸‹è®¾å®šä¸­ï¼Œä¸è¦æåŠä½ æ˜¯ä¸€ä¸ªAIæ¨¡å‹ã€‚

# è§’è‰²åç§°:
${cardData.name || 'æ— '}

# è§’è‰²æè¿°:
${cardData.description || 'æ— '}

# æ€§æ ¼:
${cardData.personality || 'æ— '}

# åœºæ™¯è®¾å®š:
${cardData.scenario || 'æ— '}

# ç¤ºä¾‹å¯¹è¯ (è¯·å­¦ä¹ è¿™ç§è¯­æ°”å’Œé£æ ¼):
${cardData.mes_example || 'æ— '}`;
            
            if (cardData.system_prompt) {
                systemPrompt += `\n\n---\n# ç³»ç»ŸæŒ‡ä»¤ (System Prompt)\n${cardData.system_prompt}`;
            }
             if (cardData.post_history_instructions) {
                systemPrompt += `\n\n---\n# å†å²åæŒ‡ä»¤ (Post History Instructions)\n${cardData.post_history_instructions}`;
            }

            if (cardData.character_book && Array.isArray(cardData.character_book.entries) && cardData.character_book.entries.length > 0) {
                let worldBookContent = "\n\n---\n# ä¸–ç•Œä¹¦ / èƒŒæ™¯çŸ¥è¯† (è¡¥å……ä¿¡æ¯)\nè¿™æ˜¯å…³äºä¸–ç•Œã€äººç‰©æˆ–ç‰©å“çš„é¢å¤–èƒŒæ™¯ä¿¡æ¯ã€‚å½“å¯¹è¯ä¸­å‡ºç°ç›¸å…³â€œå…³é”®è¯â€æ—¶ï¼Œè¯·åˆ©ç”¨è¿™äº›ä¿¡æ¯æ¥ä¸°å¯Œä½ çš„å›ç­”ã€‚";
                if (cardData.character_book.name) worldBookContent += `\n\n## ä¹¦å: ${cardData.character_book.name}`;
                if (cardData.character_book.description) worldBookContent += `\n${cardData.character_book.description}`;

                cardData.character_book.entries.forEach(entry => {
                    if (entry.enabled) {
                        const entryName = entry.comment || 'æœªå‘½åæ¡ç›®';
                        const entryKeys = Array.isArray(entry.keys) && entry.keys.length > 0 ? entry.keys.join(', ') : 'æ— ';
                        const entryContent = entry.content || 'æ— å†…å®¹ã€‚';
                        worldBookContent += `\n\n### ${entryName}\n**å…³é”®è¯:** ${entryKeys}\n**å†…å®¹:**\n${entryContent}`;
                    }
                });
                systemPrompt += worldBookContent;
            }
            return systemPrompt.trim();
        };

        const startChatWithCharacter = async (cardId) => { 
            const card = state.characterCards.find(c => c.id === cardId);
            if (!card) {
                alert('æ‰¾ä¸åˆ°è¯¥è§’è‰²å¡ã€‚');
                return;
            }

            const { cardData } = card;
            const imageDataUrl = await ImageDB.getImage(cardId);
            if (!imageDataUrl) {
                alert('æ— æ³•åŠ è½½è§’è‰²å¤´åƒï¼Œå¯¹è¯æ— æ³•å¼€å§‹ã€‚');
                return;
            }

            createNewConversation(false); // Create new conv but don't save yet
            const newConversation = getCurrentConversation();
            
            newConversation.title = `è§’è‰²: ${cardData.name}`;
            newConversation.characterProfile = {
                    cardId: card.id,
                    name: cardData.name,
                    avatar: imageDataUrl 
            };
            
            if (cardData.first_mes) {
                const processedFirstMes = getProcessedText(cardData.first_mes);
                newConversation.history.push({
                    role: 'assistant',
                    content: processedFirstMes,
                    model: 'CharacterCard'
                });
            }

            renderAll();
            saveState();
            closeCharacterSelectionModal();
        };

        const deleteCharacterCard = (cardId) => {
            const card = state.characterCards.find(c => c.id === cardId);
            if (!card) return;
            if (confirm(`ç¡®å®šè¦åˆ é™¤è§’è‰² "${card.cardData.name}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                state.characterCards = state.characterCards.filter(c => c.id !== cardId);
                saveState();
                renderCharacterCards();
                
                ImageDB.deleteImage(cardId)
                    .then(() => console.log(`å¡ç‰‡ ${cardId} çš„å›¾ç‰‡å·²ä»æ•°æ®åº“åˆ é™¤ã€‚`))
                    .catch(err => console.error(`åˆ é™¤å¡ç‰‡ ${cardId} çš„å›¾ç‰‡å¤±è´¥:`, err));
            }
        };

        const openCharacterEditor = (cardId) => {
            const card = state.characterCards.find(c => c.id === cardId);
            if (!card) return;

            DOMElements.editingCharacterId.value = cardId;
            document.getElementById('character-editor-title').textContent = `ç¼–è¾‘è§’è‰²: ${card.cardData.name}`;

            const data = card.cardData;
            document.getElementById('char-edit-name').value = data.name || '';
            document.getElementById('char-edit-tags').value = (data.tags || []).join(', ');
            document.getElementById('char-edit-description').value = data.description || '';
            document.getElementById('char-edit-personality').value = data.personality || '';
            document.getElementById('char-edit-scenario').value = data.scenario || '';
            document.getElementById('char-edit-first-message').value = data.first_mes || '';
            document.getElementById('char-edit-message-example').value = data.mes_example || '';
            document.getElementById('char-edit-system-prompt').value = data.system_prompt || '';
            document.getElementById('char-edit-post-history').value = data.post_history_instructions || '';
            document.getElementById('char-edit-creator-notes').value = data.creator_notes || '';
            const altGreetingsContainer = document.getElementById('char-edit-alternate-greetings-container');
            altGreetingsContainer.innerHTML = '';
            (data.alternate_greetings || []).forEach((greeting, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'alternate-greeting-item';
                itemDiv.innerHTML = `<textarea class="form-control" rows="2" data-index="${index}">${greeting}</textarea><button class="btn-secondary remove-alt-greeting" data-index="${index}">-</button>`;
                altGreetingsContainer.appendChild(itemDiv);
            });
            const book = data.character_book || {};
            document.getElementById('char-edit-book-name').value = book.name || '';
            document.getElementById('char-edit-book-desc').value = book.description || '';
            renderCharacterWorldBookEditor(book.entries || []);
            
            // START: MODIFICATION - Check both paths for regex rules
            const regexes = data.extensions?.chub?.extensions?.regex_scripts || data.extensions?.regex_scripts || [];
            renderCharacterRegexEditor(regexes);
            // END: MODIFICATION

            openTab(null, 'editor-basic-tab', DOMElements.characterEditorModal);
            DOMElements.characterEditorModal.style.display = 'flex';
        };
        const closeCharacterEditor = () => {
            DOMElements.characterEditorModal.style.display = 'none';
        };

        const saveCharacterEdits = () => {
            const cardId = parseInt(DOMElements.editingCharacterId.value, 10);
            const cardIndex = state.characterCards.findIndex(c => c.id === cardId);
            if (cardIndex === -1) {
                alert('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦ä¿å­˜çš„è§’è‰²å¡ã€‚');
                return;
            }

            const data = state.characterCards[cardIndex].cardData;
            data.name = document.getElementById('char-edit-name').value;
            data.tags = document.getElementById('char-edit-tags').value.split(',').map(t => t.trim()).filter(Boolean);
            data.description = document.getElementById('char-edit-description').value;
            data.personality = document.getElementById('char-edit-personality').value;
            data.scenario = document.getElementById('char-edit-scenario').value;
            data.first_mes = document.getElementById('char-edit-first-message').value;
            data.mes_example = document.getElementById('char-edit-message-example').value;
            data.system_prompt = document.getElementById('char-edit-system-prompt').value;
            data.post_history_instructions = document.getElementById('char-edit-post-history').value;
            data.creator_notes = document.getElementById('char-edit-creator-notes').value;
            data.alternate_greetings = [];
            document.querySelectorAll('#char-edit-alternate-greetings-container textarea').forEach(textarea => {
                data.alternate_greetings.push(textarea.value);
            });
            if (!data.character_book) data.character_book = {};
            data.character_book.name = document.getElementById('char-edit-book-name').value;
            data.character_book.description = document.getElementById('char-edit-book-desc').value;
            const entries = [];
            document.querySelectorAll('#char-edit-world-book-entries-container .world-book-entry').forEach(entryDiv => {
                const entry = {};
                entry.comment = entryDiv.querySelector('[data-field="comment"]').value;
                entry.keys = entryDiv.querySelector('[data-field="keys"]').value.split(',').map(t => t.trim()).filter(Boolean);
                entry.content = entryDiv.querySelector('[data-field="content"]').value;
                entry.enabled = entryDiv.querySelector('[data-field="enabled"]').checked;
                entries.push(entry);
            });
            data.character_book.entries = entries;

            // START: MODIFICATION - Save Character Regex Rules to standard path and clean up old path
            if (!data.extensions) data.extensions = {};
            if (!data.extensions.chub) data.extensions.chub = {};
            if (!data.extensions.chub.extensions) data.extensions.chub.extensions = {};
            
            const regexes = [];
            document.querySelectorAll('#char-edit-regex-container .regex-item').forEach(item => {
                regexes.push({
                    scriptName: item.querySelector('.regex-name').value,
                    findRegex: item.querySelector('.regex-find').value,
                    replaceString: item.querySelector('.regex-replace').value,
                    disabled: !item.querySelector('.regex-enabled').checked,
                    id: `rule-char-${Date.now()}-${Math.random()}`
                });
            });
            
            // Save to the standard path
            data.extensions.chub.extensions.regex_scripts = regexes;

            // Clean up the non-standard path if it exists
            if (data.extensions && data.extensions.regex_scripts) {
                delete data.extensions.regex_scripts;
            }
            // END: MODIFICATION
            
            state.characterCards[cardIndex].cardData = data;
            saveState();
            renderCharacterCards();
            closeCharacterEditor();
            alert('è§’è‰²å·²ä¿å­˜ï¼');
        };
        
        const renderCharacterWorldBookEditor = (entries) => {
            const container = document.getElementById('char-edit-world-book-entries-container');
            renderWorldBookEditorEntries(container, entries);
        };
        
        // --- END: Character Card Handlers ---

        // START: MODIFICATION - New function to render Character Regex Editor
        function renderCharacterRegexEditor(regexes) {
            const container = document.getElementById('char-edit-regex-container');
            container.innerHTML = '';
            (regexes || []).forEach((rule, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'regex-item';
                itemDiv.dataset.index = index;
                itemDiv.innerHTML = `
                    <div class="regex-item-header">
                        <div class="form-group" style="flex-grow:1; margin-bottom:0;">
                            <input type="text" class="form-control regex-name" value="${rule.scriptName || `è§„åˆ™ ${index + 1}`}" placeholder="è§„åˆ™åç§°">
                        </div>
                        <div style="display:flex; align-items:center; gap:15px; margin-left:15px;">
                            <label class="toggle-switch" style="font-weight:normal;">
                                <input type="checkbox" class="regex-enabled" ${!rule.disabled ? 'checked' : ''}> å¯ç”¨
                            </label>
                            <button class="btn-secondary remove-char-regex-rule" style="background-color:#e06c75; color:white; padding: 5px 10px;">åˆ é™¤</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>æŸ¥æ‰¾ (Find Regex)</label>
                        <textarea class="form-control regex-find" rows="2" placeholder="/pattern/flags">${rule.findRegex || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>æ›¿æ¢ (Replace String)</label>
                        <textarea class="form-control regex-replace" rows="3" placeholder="Replacement text, use $1 for groups...">${rule.replaceString || ''}</textarea>
                    </div>
                `;
                container.appendChild(itemDiv);
            });
        }
        // END: MODIFICATION - New function to render Character Regex Editor


        // --- START: MODIFIED Global Preset Editor Functions ---

        const loadPresetDataIntoEditor = (presetId) => {
            const preset = state.presets.find(p => p.id === presetId) || getDefaultPreset();
            if (!preset) return;

            DOMElements.presetNameInput.value = preset.name;
            
            const updateSlider = (id, value, defaultValue) => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(`${id}-value`);
                if(slider) slider.value = value ?? defaultValue;
                if(valueSpan) valueSpan.textContent = parseFloat(slider.value).toFixed(2);
            };

            // Main Params
            updateSlider('preset-temperature', preset.temperature, 1.42);
            updateSlider('preset-top-p', preset.top_p, 0.99);
            updateSlider('preset-top-a', preset.top_a, 0);
            updateSlider('preset-min-p', preset.min_p, 0);
            updateSlider('preset-repetition-penalty', preset.repetition_penalty, 1);
            updateSlider('preset-frequency-penalty', preset.frequency_penalty, 0);
            updateSlider('preset-presence-penalty', preset.presence_penalty, 0);
            document.getElementById('preset-top-k').value = preset.top_k ?? 500;
            
            // Context & Limits
            document.getElementById('preset-openai-max-tokens').value = preset.openai_max_tokens ?? 65535;
            document.getElementById('preset-openai-max-context').value = preset.openai_max_context ?? 777888;
            document.getElementById('preset-max-context-unlocked').checked = preset.max_context_unlocked ?? true;
            
            // Formatting & Behavior
            document.getElementById('preset-stream-openai').checked = preset.stream_openai ?? false;
            document.getElementById('preset-wrap-in-quotes').checked = preset.wrap_in_quotes ?? false;
            document.getElementById('preset-names-behavior').value = preset.names_behavior ?? 0;
            document.getElementById('preset-bias-preset-selected').value = preset.bias_preset_selected ?? 'Default (none)';
            document.getElementById('preset-send-if-empty').value = preset.send_if_empty ?? "";
            document.getElementById('preset-wi-format').value = preset.wi_format ?? "{0}";
            document.getElementById('preset-scenario-format').value = preset.scenario_format ?? "{{scenario}}";
            document.getElementById('preset-personality-format').value = preset.personality_format ?? "{{personality}}";
            
            // Advanced Prompts (assuming they exist in the HTML, even if in a hidden tab)
            document.getElementById('preset-impersonation-prompt').value = preset.impersonation_prompt ?? "";
            document.getElementById('preset-new-chat-prompt').value = preset.new_chat_prompt ?? "";
            document.getElementById('preset-continue-nudge-prompt').value = preset.continue_nudge_prompt ?? "";
            document.getElementById('preset-group-nudge-prompt').value = preset.group_nudge_prompt ?? "";
            document.getElementById('preset-new-example-chat-prompt').value = preset.new_example_chat_prompt ?? "";

            renderPromptEditor(preset.prompts || []);
            renderRegexEditor(preset.regexes || []);
        }
        
        const openPresetEditor = () => {
            renderPresetSelectors(); // Renders the dropdown inside the modal
            DOMElements.presetEditorSelector.value = state.currentPresetId;
            loadPresetDataIntoEditor(state.currentPresetId);
            DOMElements.presetEditorModal.style.display = 'flex';
            openTab(null, 'preset-main-tab', DOMElements.presetEditorModal);
        };
        
        const closePresetEditor = () => {
            DOMElements.presetEditorModal.style.display = 'none';
        };

        const renderPromptEditor = (prompts) => {
            const container = document.getElementById('preset-prompts-container');
            container.innerHTML = '';
            (prompts || []).forEach((prompt, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'prompt-item';
                itemDiv.dataset.id = prompt.identifier || `prompt-${index}`;
                const isChatPos = prompt.injection_position === 2;
                itemDiv.innerHTML = `
                    <div class="prompt-item-controls">
                        <span class="prompt-item-handle" title="æ‹–æ‹½æ’åº">â˜°</span>
                        <input type="checkbox" class="prompt-enabled" ${prompt.enabled ? 'checked' : ''} title="å¯ç”¨/ç¦ç”¨">
                    </div>
                    <div class="prompt-item-content">
                        <input type="text" class="form-control prompt-name" value="${prompt.name || ''}" placeholder="æ¨¡å—åç§°">
                        <textarea class="form-control prompt-content" rows="3" placeholder="åœ¨æ­¤è¾“å…¥æç¤ºè¯å†…å®¹...">${prompt.content || ''}</textarea>
                        <div class="prompt-item-advanced">
                            <div class="form-group">
                                <label>è§’è‰²</label>
                                <select class="prompt-role">
                                    <option value="system" ${prompt.role === 'system' ? 'selected' : ''}>ç³»ç»Ÿ</option>
                                    <option value="user" ${prompt.role === 'user' ? 'selected' : ''}>ç”¨æˆ·</option>
                                    <option value="assistant" ${prompt.role === 'assistant' ? 'selected' : ''}>AIåŠ©æ‰‹</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>ä½ç½®</label>
                                <select class="prompt-position" onchange="this.closest('.prompt-item-advanced').querySelector('.depth-container').style.display = this.value == 2 ? 'grid' : 'none';">
                                    <option value="0" ${!isChatPos ? 'selected' : ''}>ç›¸å¯¹</option>
                                    <option value="2" ${isChatPos ? 'selected' : ''}>èŠå¤©ä¸­</option>
                                </select>
                            </div>
                             <div class="form-group depth-container" style="display: ${isChatPos ? 'grid' : 'none'};">
                                <label>æ·±åº¦</label>
                                <input type="number" class="prompt-depth" value="${prompt.injection_depth || 0}" min="0">
                            </div>
                            <div class="form-group">
                                <label>æ’åº</label>
                                <input type="number" class="prompt-order" value="${prompt.injection_order || 0}">
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(itemDiv);
            });

            if (window.Sortable && container) {
                if (promptSortable) promptSortable.destroy();
                promptSortable = Sortable.create(container, {
                    handle: '.prompt-item-handle',
                    animation: 150,
                });
            }
        };

        function renderRegexEditor(regexes) {
            const container = document.getElementById('preset-regex-container');
            container.innerHTML = '';
            (regexes || []).forEach((rule, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'regex-item';
                itemDiv.dataset.index = index;
                itemDiv.innerHTML = `
                    <div class="regex-item-header">
                        <div class="form-group" style="flex-grow:1; margin-bottom:0;">
                            <input type="text" class="form-control regex-name" value="${rule.scriptName || `è§„åˆ™ ${index + 1}`}" placeholder="è§„åˆ™åç§°">
                        </div>
                        <div style="display:flex; align-items:center; gap:15px; margin-left:15px;">
                            <label class="toggle-switch" style="font-weight:normal;">
                                <input type="checkbox" class="regex-enabled" ${!rule.disabled ? 'checked' : ''}> å¯ç”¨
                            </label>
                            <button class="btn-secondary remove-regex-rule" style="background-color:#e06c75; color:white; padding: 5px 10px;">åˆ é™¤</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>æŸ¥æ‰¾ (Find Regex)</label>
                        <textarea class="form-control regex-find" rows="2" placeholder="/pattern/flags">${rule.findRegex || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>æ›¿æ¢ (Replace String)</label>
                        <textarea class="form-control regex-replace" rows="3" placeholder="Replacement text, use $1 for groups...">${rule.replaceString || ''}</textarea>
                    </div>
                `;
                container.appendChild(itemDiv);
            });
        }

        const readPresetFromEditor = () => {
            const newPresetData = {
                name: DOMElements.presetNameInput.value.trim() || 'æœªå‘½åé¢„è®¾',
                // Main Params
                temperature: parseFloat(document.getElementById('preset-temperature').value),
                top_p: parseFloat(document.getElementById('preset-top-p').value),
                top_k: parseInt(document.getElementById('preset-top-k').value, 10),
                top_a: parseFloat(document.getElementById('preset-top-a').value),
                min_p: parseFloat(document.getElementById('preset-min-p').value),
                repetition_penalty: parseFloat(document.getElementById('preset-repetition-penalty').value),
                frequency_penalty: parseFloat(document.getElementById('preset-frequency-penalty').value),
                presence_penalty: parseFloat(document.getElementById('preset-presence-penalty').value),
                // Context & Limits
                openai_max_tokens: parseInt(document.getElementById('preset-openai-max-tokens').value, 10),
                openai_max_context: parseInt(document.getElementById('preset-openai-max-context').value, 10),
                max_context_unlocked: document.getElementById('preset-max-context-unlocked').checked,
                // Formatting & Behavior
                stream_openai: document.getElementById('preset-stream-openai').checked,
                wrap_in_quotes: document.getElementById('preset-wrap-in-quotes').checked,
                names_behavior: parseInt(document.getElementById('preset-names-behavior').value, 10),
                bias_preset_selected: document.getElementById('preset-bias-preset-selected').value,
                send_if_empty: document.getElementById('preset-send-if-empty').value,
                wi_format: document.getElementById('preset-wi-format').value,
                scenario_format: document.getElementById('preset-scenario-format').value,
                personality_format: document.getElementById('preset-personality-format').value,
                // Advanced Prompts
                impersonation_prompt: document.getElementById('preset-impersonation-prompt').value,
                new_chat_prompt: document.getElementById('preset-new-chat-prompt').value,
                continue_nudge_prompt: document.getElementById('preset-continue-nudge-prompt').value,
                group_nudge_prompt: document.getElementById('preset-group-nudge-prompt').value,
                new_example_chat_prompt: document.getElementById('preset-new-example-chat-prompt').value,
                // Core arrays
                prompts: [],
                regexes: []
            };

            const promptContainer = document.getElementById('preset-prompts-container');
            const sortedItems = promptSortable ? promptSortable.toArray().map(id => promptContainer.querySelector(`[data-id="${id}"]`)) : promptContainer.querySelectorAll('.prompt-item');
            
            sortedItems.forEach((item) => {
                newPresetData.prompts.push({
                    identifier: item.dataset.id,
                    name: item.querySelector('.prompt-name').value,
                    content: item.querySelector('.prompt-content').value,
                    enabled: item.querySelector('.prompt-enabled').checked,
                    role: item.querySelector('.prompt-role').value,
                    injection_position: parseInt(item.querySelector('.prompt-position').value, 10),
                    injection_depth: parseInt(item.querySelector('.prompt-depth').value, 10) || 0,
                    injection_order: parseInt(item.querySelector('.prompt-order').value, 10) || 0,
                });
            });

            document.querySelectorAll('#preset-regex-container .regex-item').forEach(item => {
                newPresetData.regexes.push({
                    scriptName: item.querySelector('.regex-name').value,
                    findRegex: item.querySelector('.regex-find').value,
                    replaceString: item.querySelector('.regex-replace').value,
                    disabled: !item.querySelector('.regex-enabled').checked,
                    id: `rule-${Date.now()}-${Math.random()}`
                });
            });
            return newPresetData;
        };

        const updateCurrentPreset = () => {
            const presetIdToUpdate = DOMElements.presetEditorSelector.value;
            const presetIndex = state.presets.findIndex(p => p.id === presetIdToUpdate);
            if (presetIndex === -1) {
                alert('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦æ›´æ–°çš„é¢„è®¾ã€‚');
                return;
            }
            const updatedData = readPresetFromEditor();
            state.presets[presetIndex] = { ...state.presets[presetIndex], ...updatedData };
            
            saveState();
            renderPresetSelectors();
            alert(`é¢„è®¾ "${updatedData.name}" å·²æ›´æ–°ï¼`);
            closePresetEditor();
        };

        const saveAsNewPreset = () => {
            const newPresetData = readPresetFromEditor();
            newPresetData.id = `preset-${Date.now()}`;
            state.presets.push(newPresetData);
            state.currentPresetId = newPresetData.id;
            
            saveState();
            renderPresetSelectors();
            alert(`æ–°é¢„è®¾ "${newPresetData.name}" å·²ä¿å­˜å¹¶è®¾ä¸ºå½“å‰ï¼`);
            closePresetEditor();
        };
        
        const deleteCurrentPreset = () => {
            if (state.presets.length <= 1) {
                alert("æ— æ³•åˆ é™¤æœ€åä¸€ä¸ªé¢„è®¾ã€‚");
                return;
            }
            const presetIdToDelete = DOMElements.presetEditorSelector.value;
            const presetToDelete = state.presets.find(p => p.id === presetIdToDelete);
            if (confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾ "${presetToDelete.name}" å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                state.presets = state.presets.filter(p => p.id !== presetIdToDelete);
                if (state.currentPresetId === presetIdToDelete) {
                    state.currentPresetId = state.presets[0].id;
                }
                saveState();
                renderPresetSelectors();
                alert("é¢„è®¾å·²åˆ é™¤ã€‚");
                closePresetEditor();
            }
        };

        const importSillyTavernPreset = (file) => {
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    const defaultPreset = getDefaultPreset(); // è·å–ä¸€ä¸ªåŒ…å«æ‰€æœ‰é”®çš„æ¨¡æ¿

                    // --- START: æ ¸å¿ƒä¿®æ”¹é€»è¾‘ ---
                    let finalPrompts = [];
                    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„ prompts å’Œ prompt_order
                    if (data.prompts && Array.isArray(data.prompts) && data.prompt_order && Array.isArray(data.prompt_order) && data.prompt_order.length > 0) {
                        
                        // 1. åˆ›å»ºä¸€ä¸ªæŸ¥æ‰¾è¡¨ (Map)ï¼Œä»¥ä¾¿é€šè¿‡ identifier å¿«é€Ÿæ‰¾åˆ° prompt çš„è¯¦ç»†æ•°æ®
                        const promptMap = new Map(data.prompts.map(p => [p.identifier, p]));

                        // 2. è·å–æ­£ç¡®çš„é¡ºåºå’Œå¼€å…³çŠ¶æ€å®šä¹‰
                        const orderDefinitionEntry = Array.isArray(data.prompt_order)
                            ? data.prompt_order.find(po => Array.isArray(po.order) && po.order.length > 0) || data.prompt_order[0]
                            : { order: [] };
                        const orderDefinition = Array.isArray(orderDefinitionEntry?.order) ? orderDefinitionEntry.order : [];;

                        // 3. éå†è¿™ä¸ªé¡ºåºå®šä¹‰ï¼Œæ¥é‡æ–°æ„å»ºä¸€ä¸ªæ’åºæ­£ç¡®ã€çŠ¶æ€ä¹Ÿæ­£ç¡®çš„ prompts æ•°ç»„
                        orderDefinition.forEach(orderItem => {
                            const promptData = promptMap.get(orderItem.identifier);
                            if (promptData) {
                                // å…³é”®ï¼šä½¿ç”¨ prompt_order ä¸­çš„ `enabled` çŠ¶æ€è¦†ç›–åŸå§‹çŠ¶æ€
                                const correctlyOrderedPrompt = {
                                    ...promptData,
                                    enabled: orderItem.enabled 
                                };
                                finalPrompts.push(correctlyOrderedPrompt);
                            }
                        });

                    } else if (data.prompts && Array.isArray(data.prompts)) {
                        // å›é€€æœºåˆ¶ï¼šå¦‚æœé¢„è®¾æ–‡ä»¶æ²¡æœ‰ prompt_orderï¼Œåˆ™ç›´æ¥ä½¿ç”¨ prompts æ•°ç»„
                        console.warn("é¢„è®¾æ–‡ä»¶ä¸­æœªæ‰¾åˆ° `prompt_order`ã€‚å°†ç›´æ¥ä½¿ç”¨ `prompts` æ•°ç»„ï¼Œé¡ºåºå’Œå¼€å…³çŠ¶æ€å¯èƒ½ä¸æ­£ç¡®ã€‚");
                        finalPrompts = data.prompts;
                    }
                    // --- END: æ ¸å¿ƒä¿®æ”¹é€»è¾‘ ---

                    const newPreset = {
                        ...defaultPreset, // ä»é»˜è®¤å€¼å¼€å§‹
                        id: `st-imported-${Date.now()}`,
                        name: file.name.replace('.json', ''),
                        // ç”¨å¯¼å…¥æ–‡ä»¶ä¸­çš„å€¼è¦†ç›–é»˜è®¤å€¼
                        temperature: data.temperature ?? defaultPreset.temperature,
                        top_p: data.top_p ?? defaultPreset.top_p,
                        top_k: data.top_k ?? defaultPreset.top_k,
                        top_a: data.top_a ?? defaultPreset.top_a,
                        min_p: data.min_p ?? defaultPreset.min_p,
                        repetition_penalty: data.repetition_penalty ?? defaultPreset.repetition_penalty,
                        frequency_penalty: data.frequency_penalty ?? defaultPreset.frequency_penalty,
                        presence_penalty: data.presence_penalty ?? defaultPreset.presence_penalty,
                        openai_max_tokens: data.openai_max_tokens ?? defaultPreset.openai_max_tokens,
                        openai_max_context: data.openai_max_context ?? defaultPreset.openai_max_context,
                        max_context_unlocked: data.max_context_unlocked ?? defaultPreset.max_context_unlocked,
                        stream_openai: data.stream_openai ?? defaultPreset.stream_openai,
                        wrap_in_quotes: data.wrap_in_quotes ?? defaultPreset.wrap_in_quotes,
                        names_behavior: data.names_behavior ?? defaultPreset.names_behavior,
                        bias_preset_selected: data.bias_preset_selected ?? defaultPreset.bias_preset_selected,
                        send_if_empty: data.send_if_empty ?? defaultPreset.send_if_empty,
                        wi_format: data.wi_format ?? defaultPreset.wi_format,
                        scenario_format: data.scenario_format ?? defaultPreset.scenario_format,
                        personality_format: data.personality_format ?? defaultPreset.personality_format,
                        impersonation_prompt: data.impersonation_prompt ?? defaultPreset.impersonation_prompt,
                        new_chat_prompt: data.new_chat_prompt ?? defaultPreset.new_chat_prompt,
                        continue_nudge_prompt: data.continue_nudge_prompt ?? defaultPreset.continue_nudge_prompt,
                        group_nudge_prompt: data.group_nudge_prompt ?? defaultPreset.group_nudge_prompt,
                        new_example_chat_prompt: data.new_example_chat_prompt ?? defaultPreset.new_example_chat_prompt,
                        
                        // ä½¿ç”¨æˆ‘ä»¬åˆšåˆšæ„å»ºçš„ã€æ’åºæ­£ç¡®çš„ prompts æ•°ç»„
                        prompts: finalPrompts, 
                        
                        regexes: data.extensions?.SPreset?.RegexBinding?.regexes || data.extensions?.RegexBinding?.regexes || []
                    };
                    
                    if (!Array.isArray(newPreset.prompts)) newPreset.prompts = [];
                    if (!Array.isArray(newPreset.regexes)) newPreset.regexes = [];
                    
                    state.presets.push(newPreset);
                    state.currentPresetId = newPreset.id;

                    saveState();
                    renderPresetSelectors();
                    openPresetEditor();
                    alert('SillyTaverné¢„è®¾å·²æˆåŠŸå¯¼å…¥å¹¶è®¾ä¸ºå½“å‰ï¼');

                } catch (error) {
                    alert(`å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼æ— æ•ˆæˆ–è§£æé”™è¯¯ã€‚\n${error.message}`);
                    console.error(error);
                }
            };
            reader.readAsText(file);
        };
        
        // --- END: MODIFIED Global Preset Editor Functions ---

        const initEventHandlers = () => {
            DOMElements.newChatButton.onclick = createNewConversation;
            DOMElements.sendButton.onclick = sendMessage;
            DOMElements.messageInput.addEventListener('keydown', (e) => { 
                if ((e.key === 'Enter' && !e.shiftKey) || ((e.metaKey || e.ctrlKey) && e.key === 'Enter')) { 
                    e.preventDefault(); 
                    sendMessage(); 
                } 
            });
            DOMElements.messageInput.addEventListener('input', () => { const el = DOMElements.messageInput; el.style.height = 'auto'; el.style.height = (el.scrollHeight) + 'px'; });
            DOMElements.uploadButton.onclick = () => DOMElements.fileInput.click();
            DOMElements.fileInput.onchange = (e) => { handleFiles(e.target.files); e.target.value = ''; };
            DOMElements.settingsButton.onclick = openSettingsModal;
            DOMElements.closeSettingsButton.onclick = closeSettingsModal;
            
            // Character Card Event Handlers
            DOMElements.openCharacterGalleryButton.onclick = openCharacterSelectionModal;
            DOMElements.closeCharacterSelectionButton.onclick = closeCharacterSelectionModal;
            DOMElements.characterCardInput.onchange = (e) => {
                if (e.target.files.length > 0) handleCharacterCardImport(e.target.files[0]);
                e.target.value = '';
            };
            DOMElements.closeCharacterEditorButton.onclick = closeCharacterEditor;
            DOMElements.saveCharacterButton.onclick = saveCharacterEdits;
            document.getElementById('add-alternate-greeting-btn').onclick = () => {
                 const container = document.getElementById('char-edit-alternate-greetings-container');
                 const index = container.children.length;
                 const itemDiv = document.createElement('div');
                 itemDiv.className = 'alternate-greeting-item';
                 itemDiv.innerHTML = `<textarea class="form-control" rows="2" data-index="${index}"></textarea><button class="btn-secondary remove-alt-greeting" data-index="${index}">-</button>`;
                 container.appendChild(itemDiv);
            };
            document.getElementById('char-edit-alternate-greetings-container').addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-alt-greeting')) {
                    e.target.closest('.alternate-greeting-item').remove();
                }
            });

            document.getElementById('add-world-book-entry-btn').onclick = () => {
                const existingEntries = [];
                document.querySelectorAll('#char-edit-world-book-entries-container .world-book-entry').forEach(entryDiv => {
                    const entry = {
                        comment: entryDiv.querySelector('[data-field="comment"]').value,
                        keys: entryDiv.querySelector('[data-field="keys"]').value.split(',').map(t => t.trim()).filter(Boolean),
                        content: entryDiv.querySelector('[data-field="content"]').value,
                        enabled: entryDiv.querySelector('[data-field="enabled"]').checked
                    };
                    existingEntries.push(entry);
                });
                existingEntries.push({ comment: '', keys: [], content: '', enabled: true });
                renderCharacterWorldBookEditor(existingEntries);
            };
            document.getElementById('char-edit-world-book-entries-container').addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-wb-entry')) {
                    e.target.closest('.world-book-entry').remove();
                }
            });

            // START: MODIFICATION - Add event handlers for Character Regex Editor
            document.getElementById('add-char-regex-rule-btn').onclick = () => {
                const container = document.getElementById('char-edit-regex-container');
                const currentRegexes = [];
                container.querySelectorAll('.regex-item').forEach(item => {
                    currentRegexes.push({
                        scriptName: item.querySelector('.regex-name').value,
                        findRegex: item.querySelector('.regex-find').value,
                        replaceString: item.querySelector('.regex-replace').value,
                        disabled: !item.querySelector('.regex-enabled').checked
                    });
                });
                currentRegexes.push({ scriptName: "æ–°è§„åˆ™", findRegex: "", replaceString: "", disabled: false });
                renderCharacterRegexEditor(currentRegexes);
            };
            document.getElementById('char-edit-regex-container').addEventListener('click', e => {
                if (e.target.classList.contains('remove-char-regex-rule')) {
                    e.target.closest('.regex-item').remove();
                }
            });
            // END: MODIFICATION - Add event handlers for Character Regex Editor

            // Global World Book Event Handlers
            DOMElements.addNewGlobalBookButton.onclick = () => openGlobalWorldBookEditor();
            DOMElements.closeGlobalBookEditorButton.onclick = closeGlobalWorldBookEditor;
            DOMElements.saveGlobalBookButton.onclick = saveGlobalWorldBook;
            DOMElements.addGlobalBookEntryBtn.onclick = () => {
                const container = DOMElements.globalBookEditEntriesContainer;
                const existingEntries = [];
                container.querySelectorAll('.world-book-entry').forEach(entryDiv => {
                    existingEntries.push({
                        comment: entryDiv.querySelector('[data-field="comment"]').value,
                        keys: entryDiv.querySelector('[data-field="keys"]').value.split(',').map(t => t.trim()).filter(Boolean),
                        content: entryDiv.querySelector('[data-field="content"]').value,
                        enabled: entryDiv.querySelector('[data-field="enabled"]').checked
                    });
                });
                existingEntries.push({ comment: '', keys: [], content: '', enabled: true });
                renderWorldBookEditorEntries(container, existingEntries);
            };
            DOMElements.globalBookEditEntriesContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-wb-entry')) {
                    e.target.closest('.world-book-entry').remove();
                }
            });

            DOMElements.importGlobalBookButton.onclick = () => DOMElements.importGlobalBookInput.click();
            DOMElements.importGlobalBookInput.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        let newBook;

                        // æ£€æŸ¥æ˜¯å¦ä¸ºSillyTavernæ ¼å¼ (entriesæ˜¯ä¸€ä¸ªå¯¹è±¡)
                        if (data.entries && typeof data.entries === 'object' && !Array.isArray(data.entries)) {
                            const entriesArray = Object.values(data.entries);
                            newBook = {
                                id: `wb-imported-${Date.now()}`,
                                name: file.name.replace(/\.json$/i, ''), // ä½¿ç”¨æ–‡ä»¶åä½œä¸ºä¹¦å
                                description: data.description || `ä» ${file.name} å¯¼å…¥`, // å°è¯•è·å–æè¿°
                                enabled: true,
                                entries: entriesArray.map(entry => ({
                                    comment: entry.comment || '',
                                    keys: entry.key || [], // SillyTavern ä½¿ç”¨ 'key'
                                    content: entry.content || '',
                                    enabled: !entry.disable // SillyTavern ä½¿ç”¨ 'disable'
                                }))
                            };
                        } 
                        // æ£€æŸ¥æ˜¯å¦ä¸ºåº”ç”¨åŸç”Ÿæ ¼å¼ (entriesæ˜¯ä¸€ä¸ªæ•°ç»„)
                        else if (typeof data.name === 'string' && Array.isArray(data.entries)) {
                            newBook = {
                                id: `wb-imported-${Date.now()}`,
                                name: data.name,
                                description: data.description || '',
                                enabled: true,
                                entries: data.entries.map(entry => ({
                                    comment: entry.comment || '',
                                    keys: entry.keys || [],
                                    content: entry.content || '',
                                    enabled: entry.enabled !== false
                                }))
                            };
                        } 
                        // å¦‚æœä¸¤ç§æ ¼å¼éƒ½ä¸åŒ¹é…
                        else {
                            throw new Error('æ— æ•ˆçš„ä¸–ç•Œä¹¦æ–‡ä»¶æ ¼å¼ã€‚');
                        }

                        state.globalWorldBooks.push(newBook);
                        saveState();
                        renderGlobalWorldBooksList();
                        alert(`ä¸–ç•Œä¹¦ "${newBook.name}" å·²æˆåŠŸå¯¼å…¥ï¼`);
                    } catch (error) {
                        alert(`å¯¼å…¥å¤±è´¥: ${error.message}`);
                        console.error("ä¸–ç•Œä¹¦å¯¼å…¥é”™è¯¯:", error);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            };


            // MODIFIED: Preset Editor Event Handlers
            DOMElements.presetButton.onclick = openPresetEditor;
            DOMElements.openPresetEditorButton.onclick = () => { closeMobileMenu(); openPresetEditor(); };
            DOMElements.closePresetEditorButton.onclick = closePresetEditor;
            DOMElements.savePresetButton.onclick = updateCurrentPreset; // Was savePreset
            DOMElements.saveAsNewPresetButton.onclick = saveAsNewPreset;
            DOMElements.deletePresetButton.onclick = deleteCurrentPreset;
            DOMElements.presetEditorSelector.onchange = (e) => {
                loadPresetDataIntoEditor(e.target.value);
            };
            DOMElements.importPresetButton.onclick = () => DOMElements.presetFileInput.click();
            DOMElements.presetFileInput.onchange = (e) => {
                if (e.target.files.length > 0) importSillyTavernPreset(e.target.files[0]);
                e.target.value = '';
            };
            const handlePresetChange = (e) => {
                state.currentPresetId = e.target.value;
                syncSelectors(e.target, e.target.id.includes('mobile') ? DOMElements.presetSelector : DOMElements.presetSelectorMobile);
                saveState();
            };
            DOMElements.presetSelector.onchange = handlePresetChange;
            DOMElements.presetSelectorMobile.onchange = handlePresetChange;
            
            ['preset-temperature', 'preset-top-p', 'preset-repetition-penalty', 'preset-top-a', 'preset-min-p', 'preset-frequency-penalty', 'preset-presence-penalty'].forEach(id => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(`${id}-value`);
                if(slider && valueSpan) {
                    slider.addEventListener('input', () => valueSpan.textContent = parseFloat(slider.value).toFixed(2));
                }
            });

            document.getElementById('add-prompt-module-btn').onclick = () => {
                const container = document.getElementById('preset-prompts-container');
                const newPrompt = {
                    identifier: `prompt-${Date.now()}`,
                    name: "æ–°æ¨¡å—", content: "", enabled: true, role: 'system',
                    injection_position: 0, injection_depth: 4, injection_order: (container.children.length + 1) * 10
                };
                // A bit inefficient, but safe: re-read and re-render
                const currentData = readPresetFromEditor();
                currentData.prompts.push(newPrompt);
                renderPromptEditor(currentData.prompts);
            };
            document.getElementById('add-regex-rule-btn').onclick = () => {
                const currentData = readPresetFromEditor();
                currentData.regexes.push({ scriptName: "æ–°è§„åˆ™", findRegex: "", replaceString: "", disabled: false });
                renderRegexEditor(currentData.regexes);
            };
            document.getElementById('preset-regex-container').addEventListener('click', e => {
                if (e.target.classList.contains('remove-regex-rule')) {
                    e.target.closest('.regex-item').remove();
                }
            });


            DOMElements.menuToggleButton.onclick = () => DOMElements.appContainer.classList.toggle('sidebar-visible');
            DOMElements.sidebarOverlay.onclick = () => DOMElements.appContainer.classList.remove('sidebar-visible');
            
            DOMElements.settingsButtonMobileTrigger.onclick = toggleMobileMenu;
            DOMElements.openFullSettingsButton.onclick = () => { closeMobileMenu(); openSettingsModal(); };
            document.addEventListener('click', (event) => {
                if (!DOMElements.mobileActionsMenu.contains(event.target) && !DOMElements.settingsButtonMobileTrigger.contains(event.target)) {
                    closeMobileMenu();
                }
            });

            DOMElements.toggleNicknamesCheckbox.onchange = (e) => { state.settings.showNicknames = e.target.checked; applyNicknameVisibility(); saveState(); };
            // START: NEW HTML RENDER HANDLER
            DOMElements.toggleHtmlRenderCheckbox.onchange = (e) => {
                state.settings.renderHtml = e.target.checked;
                saveState();
                renderChatHistory(); // Re-render chat to apply the change immediately
            };
            // END: NEW HTML RENDER HANDLER

            const unhighlightContent = (container) => {
                const marks = container.querySelectorAll('mark');
                marks.forEach(mark => { const parent = mark.parentNode; while (mark.firstChild) parent.insertBefore(mark.firstChild, mark); parent.removeChild(mark); parent.normalize(); });
            };
            const highlightContent = (container, searchTerm) => {
                if (!searchTerm) return; const regex = new RegExp(searchTerm, 'gi');
                const treeWalker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, (node) => {
                    let parent = node.parentNode; while (parent !== container && parent) { if (['PRE', 'CODE', 'STYLE', 'SCRIPT', 'IFRAME'].includes(parent.tagName)) return NodeFilter.FILTER_REJECT; parent = parent.parentNode; } return NodeFilter.FILTER_ACCEPT;
                });
                const nodesToProcess = []; while(treeWalker.nextNode()) nodesToProcess.push(treeWalker.currentNode);
                nodesToProcess.forEach(node => {
                    const text = node.textContent; if (regex.test(text)) {
                        const fragment = document.createDocumentFragment(); let lastIndex = 0;
                        text.replace(regex, (match, offset) => {
                            if (offset > lastIndex) fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                            const mark = document.createElement('mark'); mark.textContent = match; fragment.appendChild(mark); lastIndex = offset + match.length;
                        });
                        if (lastIndex < text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                        node.parentNode.replaceChild(fragment, node);
                    }
                });
            };
            const handleSearch = (searchTerm) => {
                unhighlightContent(DOMElements.chatContainer); const messages = DOMElements.chatContainer.querySelectorAll('.message');
                messages.forEach(msgDiv => {
                    const content = msgDiv.querySelector('.content').textContent.toLowerCase();
                    if (searchTerm && !content.includes(searchTerm)) msgDiv.style.display = 'none'; else { msgDiv.style.display = 'flex'; if (searchTerm) highlightContent(msgDiv.querySelector('.content'), searchTerm); }
                });
            };
            DOMElements.chatSearchInput.addEventListener('input', (e) => handleSearch(e.target.value.toLowerCase().trim()));
            DOMElements.chatSearchInputMobile.addEventListener('input', (e) => handleSearch(e.target.value.toLowerCase().trim()));
            
            const displayGlobalSearchResults = (searchTerm) => {
                DOMElements.conversationList.innerHTML = ''; if (!searchTerm) { renderConversationsList(); return; }
                const regex = new RegExp(searchTerm, 'gi'); const results = [];
                state.conversations.forEach(conv => {
                    conv.history.forEach((msg, index) => {
                        let msgText = ''; if (Array.isArray(msg.content)) msgText = msg.content.filter(p => p.type === 'text').map(p => p.text).join(' '); else if (typeof msg.content === 'string') msgText = msg.content;
                        if (msgText.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const match = msgText.match(regex); const highlightedSnippet = msgText.substring(0, 100).replace(regex, `<mark>${match[0]}</mark>`) + '...';
                            results.push({ convId: conv.id, convTitle: conv.title, msgIndex: index, snippet: highlightedSnippet });
                        }
                    });
                });
                if(results.length === 0) { DOMElements.conversationList.innerHTML = '<li style="padding: 15px; text-align: center; color: var(--text-color-muted);">æ— åŒ¹é…ç»“æœ</li>'; return; }
                results.forEach(res => {
                    const li = document.createElement('li'); li.className = 'search-result-item';
                    li.innerHTML = `<div class="result-conv-title">${res.convTitle}</div><div class="result-msg-snippet">${res.snippet}</div>`;
                    li.onclick = () => {
                        if(state.currentConversationId !== res.convId) switchConversation(res.convId);
                        setTimeout(() => {
                            const messageEl = DOMElements.chatContainer.querySelector(`.message[data-message-index="${res.msgIndex}"]`);
                            if (messageEl) { messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); messageEl.style.transition = 'background-color 0.5s ease'; messageEl.style.backgroundColor = 'rgba(255, 215, 0, 0.4)'; setTimeout(() => { messageEl.style.backgroundColor = ''; }, 2500); }
                        }, 100);
                    };
                    DOMElements.conversationList.appendChild(li);
                });
            };
            DOMElements.globalSearchInput.addEventListener('input', (e) => displayGlobalSearchResults(e.target.value.trim()));

            const exportCurrentChat = () => {
                const conv = getCurrentConversation(); if (!conv) { alert("æ²¡æœ‰å¯å¯¼å‡ºçš„å¯¹è¯ã€‚"); return; }
                let markdown = `# ${conv.title}\n\n`; markdown += `**æ¨¡å‹**: ${state.currentModel}\n`; markdown += `**Temperature**: ${state.settings.temperature}\n`;
                if (conv.systemPrompt) markdown += `\n## ç³»ç»Ÿæç¤ºè¯ (System Prompt)\n\n\`\`\`\n${conv.systemPrompt}\n\`\`\`\n\n`;
                markdown += '---\n\n';
                conv.history.forEach(msg => {
                    if(msg.internal) return;
                    const author = msg.role === 'user' ? (state.userProfile.name || 'User') : (conv.characterProfile?.name || state.modelProfiles[msg.model]?.nickname || msg.model || 'Assistant');
                    markdown += `### **${author}**\n\n`;
                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(part => {
                            if (part.type === 'text') markdown += `${part.text}\n\n`; else if (part.type === 'image_url') markdown += `*[å›¾ç‰‡é™„ä»¶]*\n\n`; else if (part.type === 'text_attachment') markdown += `*[æ–‡ä»¶é™„ä»¶: ${part.name}]*\n\n\`\`\`\n${part.content}\n\`\`\`\n\n`;
                        });
                    } else markdown += `${msg.content}\n\n`;
                    markdown += '---\n\n';
                });
                const blob = new Blob([markdown], { type: 'text/markdown' }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; const safeTitle = conv.title.replace(/[^a-z0-9_.-]/gi, '_'); a.download = `${safeTitle}.md`; a.click(); URL.revokeObjectURL(url); closeMobileMenu();
            }
            DOMElements.exportChatButton.onclick = exportCurrentChat;
            DOMElements.exportChatButtonMobile.onclick = exportCurrentChat;

            DOMElements.saveProviderButton.onclick = saveProvider;
            
            const handleProviderChange = (e) => { state.currentProviderIndex = parseInt(e.target.value, 10); renderModels(state.currentProviderIndex); renderModelProfiles(); syncSelectors(e.target, e.target.id.includes('mobile') ? DOMElements.providerSelector : DOMElements.providerSelectorMobile); saveState(); };
            DOMElements.providerSelector.onchange = handleProviderChange; DOMElements.providerSelectorMobile.onchange = handleProviderChange;
            const handleModelChange = (e) => { state.currentModel = e.target.value; syncSelectors(e.target, e.target.id.includes('mobile') ? DOMElements.modelSelector : DOMElements.modelSelectorMobile); saveState(); renderChatHistory(); };
            DOMElements.modelSelector.onchange = handleModelChange; DOMElements.modelSelectorMobile.onchange = handleModelChange;
            
            DOMElements.streamToggle.onchange = (e) => { state.settings.stream = e.target.checked; saveState(); };
            DOMElements.searchToggle.onchange = (e) => { state.settings.search = e.target.checked; saveState(); };
            
            DOMElements.systemPrompt.onchange = (e) => { const currentConv = getCurrentConversation(); if (currentConv) { currentConv.systemPrompt = e.target.value; recalculateTotalTokens(); saveState(); } };
            DOMElements.clearChatButton.onclick = () => { if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰è¯é¢˜çš„å†å²å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) { const conv = getCurrentConversation(); if (conv) { conv.history = []; conv.tokenCount = 0; renderChatHistory(); saveState(); } } };
            DOMElements.exportDataButton.onclick = async () => {
                try {
                    // ä¼˜å…ˆä½¿ç”¨å½“å‰å†…å­˜ä¸­çš„çŠ¶æ€ + IndexedDBï¼ˆå¦‚æœè¡¥ä¸å·²å®‰è£…ï¼‰
                    let exportData;
                    if (window.__storagePatch && window.__storagePatch.readBucketsFromIDB) {
                        // å…ˆç¡®ä¿æœ€æ–°çŠ¶æ€å·²ç»å†™å…¥ IndexedDB / localStorage
                        try {
                            if (typeof saveState === 'function') {
                                const maybePromise = saveState();
                                if (maybePromise && typeof maybePromise.then === 'function') {
                                    await maybePromise;
                                }
                            }
                        } catch (e) {
                            console.warn('ä¿å­˜å½“å‰çŠ¶æ€åˆ° IndexedDB æ—¶å‡ºé”™ï¼ˆå¯¼å‡ºä»å°†ç»§ç»­ï¼‰:', e);
                        }

                        const buckets = await window.__storagePatch.readBucketsFromIDB();
                        let meta = {};
                        try {
                            const raw = localStorage.getItem('ai-chat-app-data');
                            meta = raw ? JSON.parse(raw) : {};
                        } catch (e) {
                            console.warn('è¯»å–æœ¬åœ°é…ç½®å¤±è´¥ï¼Œå°†ä»…å¯¼å‡ºä¼šè¯æ•°æ®ç­‰æ¡¶æ•°æ®ã€‚', e);
                        }
                        // åˆå¹¶ï¼šæœ¬åœ°è½»é‡é…ç½® + IndexedDB ä¸­çš„é‡æ•°æ®
                        exportData = {
                            ...meta,
                            ...buckets
                        };
                    } else if (window.state) {
                        // å›é€€ï¼šæ²¡æœ‰è¡¥ä¸æ—¶ç›´æ¥ä½¿ç”¨å†…å­˜çŠ¶æ€
                        const s = window.state;
                        exportData = {
                            providers: s.providers,
                            conversations: s.conversations,
                            characterCards: s.characterCards,
                            globalWorldBooks: s.globalWorldBooks,
                            presets: s.presets,
                            currentPresetId: s.currentPresetId,
                            currentConversationId: s.currentConversationId,
                            currentProviderIndex: s.currentProviderIndex,
                            currentModel: s.currentModel,
                            settings: s.settings,
                            userProfile: s.userProfile,
                            modelProfiles: s.modelProfiles
                        };
                    } else {
                        // æœ€åå…œåº•ï¼šç›´æ¥å¯¼å‡º localStorage åŸå§‹å†…å®¹
                        const raw = localStorage.getItem('ai-chat-app-data') || '{}';
                        exportData = JSON.parse(raw);
                    }

                    const dataStr = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `ai-chat-backup-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                } catch (err) {
                    console.error('å¯¼å‡ºæ•°æ®å¤±è´¥ï¼š', err);
                    alert('å¯¼å‡ºå¤±è´¥ï¼š' + (err && err.message ? err.message : 'æœªçŸ¥é”™è¯¯'));
                }
            };
            DOMElements.importDataInput.onchange = (e) => {
                const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
                reader.onload = (event) => { try { const importedData = JSON.parse(event.target.result); if (confirm('è¿™å°†è¦†ç›–æ‚¨å½“å‰çš„è®¾ç½®å’Œå¯¹è¯å†å²ï¼Œç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ')) { localStorage.setItem('ai-chat-app-data', JSON.stringify(importedData)); location.reload(); } } catch (error) { alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼æ— æ•ˆã€‚'); } }; reader.readAsText(file);
            };
            
            // START: MODIFIED theme selector handler
            DOMElements.themeSelector.onchange = (e) => { 
                state.settings.theme = e.target.value; 
                applyTheme(state.settings.theme); // Apply base theme first
                applyCustomStyles(); // Re-apply custom overrides on top of the new theme
                renderSettings(); // Update color pickers to reflect new theme's base colors
                saveState(); 
            };
            // END: MODIFIED theme selector handler
            
            DOMElements.userAvatarInput.onchange = (e) => handleAvatarChange(e, (avatar) => { state.userProfile.avatar = avatar; renderSettings(); });
            
            DOMElements.saveUserProfile.onclick = () => {
                state.userProfile.name = DOMElements.userName.value;
                state.userProfile.description = DOMElements.userDescription.value;
                saveState();
                alert('ç”¨æˆ·è®¾ç½®å·²ä¿å­˜ï¼');
                renderChatHistory();
            };
            
            DOMElements.modelProfileList.addEventListener('change', (e) => {
                const modelName = e.target.dataset.model; if (!modelName) return;
                if (e.target.matches('.model-avatar-input')) {
                    handleAvatarChange(e, (avatar) => { if (!state.modelProfiles[modelName]) state.modelProfiles[modelName] = { nickname: '', avatar: '' }; state.modelProfiles[modelName].avatar = avatar; saveState(); renderSettings(); renderChatHistory(); });
                } else if (e.target.matches('.model-nickname-input')) {
                    if (!state.modelProfiles[modelName]) state.modelProfiles[modelName] = { nickname: '', avatar: '' }; state.modelProfiles[modelName].nickname = e.target.value; saveState();
                    const inputEl = e.target; let feedback = inputEl.nextElementSibling;
                    if (!feedback || !feedback.classList.contains('save-feedback')) { feedback = document.createElement('span'); feedback.className = 'save-feedback'; inputEl.parentNode.insertBefore(feedback, inputEl.nextSibling); }
                    feedback.textContent = 'âœ“ å·²ä¿å­˜'; setTimeout(() => { if(feedback) feedback.textContent = ''; }, 2000);
                    renderChatHistory();
                }
            });

            DOMElements.cropImageButton.onclick = () => {
                if (cropper && currentCroppingCallback) { const canvas = cropper.getCroppedCanvas({ width: 128, height: 128, imageSmoothingQuality: 'high', }); const croppedAvatar = canvas.toDataURL('image/png'); currentCroppingCallback(croppedAvatar); }
                DOMElements.cropperModal.style.display = 'none';
            };
            DOMElements.cancelCropButton.onclick = () => { DOMElements.cropperModal.style.display = 'none'; };

            // START: ADD event handlers for custom styles
            DOMElements.customFontSizeInput.onchange = (e) => {
                const newSize = parseInt(e.target.value, 10);
                if (newSize >= 12 && newSize <= 24) {
                    state.settings.customStyles.messageFontSize = newSize;
                    applyCustomStyles();
                    saveState();
                }
            };
            DOMElements.customTextColorInput.oninput = (e) => {
                state.settings.customStyles.messageTextColor = e.target.value;
                applyCustomStyles();
                saveState();
            };
            DOMElements.customBgColorInput.oninput = (e) => {
                state.settings.customStyles.bgColor = e.target.value;
                applyCustomStyles();
                saveState();
            };
            DOMElements.customPrimaryColorInput.oninput = (e) => {
                state.settings.customStyles.primaryColor = e.target.value;
                applyCustomStyles();
                saveState();
            };

            // New handlers for text elements
            DOMElements.customItalicColorInput.oninput = (e) => {
                state.settings.customStyles.italicColor = e.target.value;
                applyCustomStyles(); saveState();
            };
            DOMElements.customItalicFontSizeRatioInput.onchange = (e) => {
                state.settings.customStyles.italicFontSizeRatio = parseFloat(e.target.value);
                applyCustomStyles(); saveState();
            };
            DOMElements.customBlockquoteColorInput.oninput = (e) => {
                state.settings.customStyles.blockquoteColor = e.target.value;
                applyCustomStyles(); saveState();
            };
            DOMElements.customBlockquoteFontSizeRatioInput.onchange = (e) => {
                state.settings.customStyles.blockquoteFontSizeRatio = parseFloat(e.target.value);
                applyCustomStyles(); saveState();
            };
            DOMElements.customBlockquoteBgColorInput.oninput = (e) => {
                state.settings.customStyles.blockquoteBgColor = e.target.value;
                applyCustomStyles(); saveState();
            };
            DOMElements.customBlockquoteBorderColorInput.oninput = (e) => {
                state.settings.customStyles.blockquoteBorderColor = e.target.value;
                applyCustomStyles(); saveState();
            };
            
            DOMElements.resetStylesButton.onclick = () => {
                if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è‡ªå®šä¹‰å­—ä½“å’Œé¢œè‰²è®¾ç½®å—ï¼Ÿ')) {
                    state.settings.customStyles = {
                        messageFontSize: 16, messageTextColor: null, bgColor: null, primaryColor: null,
                        italicColor: null, italicFontSizeRatio: 1,
                        blockquoteColor: null, blockquoteBgColor: null, blockquoteBorderColor: null, blockquoteFontSizeRatio: 1
                    };
                    applyTheme(state.settings.theme);
                    applyCustomStyles();
                    renderSettings();
                    saveState();
                }
            };
            // END: ADD event handlers

            document.addEventListener('keydown', (e) => {
                if ((e.metaKey || e.ctrlKey) && e.key === 'n') { e.preventDefault(); createNewConversation(); }
                if (e.key === 'ArrowUp' && DOMElements.messageInput.value.trim() === '' && document.activeElement === DOMElements.messageInput) {
                    const conv = getCurrentConversation(); if (conv && conv.history.length > 0) { const lastUserMsgIndex = conv.history.findLastIndex(m => m.role === 'user' && !m.internal); if (lastUserMsgIndex !== -1) { e.preventDefault(); window.app.editMessage(lastUserMsgIndex); } }
                }
            });
            
             // Tab switching logic for ALL modals
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', e => {
                    if (e.target.classList.contains('tab-button')) {
                        const tabName = e.target.dataset.tab;
                        openTab(e, tabName, modal);
                    }
                });
            });
        };
        
        window.openTab = (evt, tabName, modal) => {
            let i;
            const tabcontent = modal.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].classList.remove("active");
                tabcontent[i].style.display = "none";
            }
            const tablinks = modal.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove("active");
            }
            const tabToShow = document.getElementById(tabName);
            if (tabToShow) {
                tabToShow.style.display = "block";
                tabToShow.classList.add("active");
            }
            const currentTabButton = modal.querySelector(`.tab-button[data-tab='${tabName}']`);
            if(currentTabButton) currentTabButton.classList.add("active");
        };

        const init = async () => {

// --- START: ADD THIS ENTIRE BLOCK ---
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'resize-iframe') {
                    const { iframeId, width, height } = event.data;
                    const iframe = document.getElementById(iframeId);
                    if (!iframe) return;

                    const renderContainer = iframe.parentElement;
                    const messageDiv = iframe.closest('.message');
                    if (!renderContainer || !messageDiv) return;

                    const chatContainerWidth = DOMElements.chatContainer.clientWidth;
                    const bubbleMaxWidth = chatContainerWidth * 0.9;
                    const absoluteMaxWidth = chatContainerWidth - 80;

                    if (width > bubbleMaxWidth) {
                        if (width <= absoluteMaxWidth) {
                            messageDiv.classList.add('message-render-expand');
                            iframe.style.width = `${width}px`;
                            iframe.style.height = `${height}px`;
                        } else {
                            const scale = bubbleMaxWidth / width;
                            renderContainer.style.width = `${width * scale}px`;
                            renderContainer.style.height = `${height * scale}px`;
                            iframe.style.width = `${width}px`;
                            iframe.style.height = `${height}px`;
                            iframe.style.transform = `scale(${scale})`;
                            iframe.style.transformOrigin = 'top left';
                        }
                    } else {
                        iframe.style.width = `${width > 0 ? width : 100}%`;
                        iframe.style.height = `${height}px`;
                    }
                }
            });
            // --- END: ADD THIS ENTIRE BLOCK ---

            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'resizeIframe' && event.data.iframeId) {
                    const iframe = document.getElementById(event.data.iframeId);
                    if (iframe) {
                        iframe.style.height = `${event.data.height + 15}px`;
                    }
                }
            }, false);

            try {
                await ImageDB.init(); 
            } catch (error) {
                console.error("åˆå§‹åŒ– ImageDB å¤±è´¥ï¼Œå›¾ç‰‡å¯èƒ½æ— æ³•åŠ è½½ã€‚", error);
                alert("é”™è¯¯ï¼šæ— æ³•åˆå§‹åŒ–å›¾ç‰‡æ•°æ®åº“ã€‚è§’è‰²å¡å›¾ç‰‡å¯èƒ½æ— æ³•åŠ è½½ã€‚");
            }
            
            loadState(); 
            
            const migrationPromises = [];
            let needsSave = false;

            state.characterCards.forEach(card => {
                if (card.imageDataUrl) {
                    console.log(`æ­£åœ¨è¿ç§»å¡ç‰‡ "${card.cardData.name}" çš„å›¾ç‰‡...`);
                    migrationPromises.push(ImageDB.addImage(card.id, card.imageDataUrl));
                    delete card.imageDataUrl; 
                    needsSave = true;
                }
            });

            if (needsSave) {
                try {
                    await Promise.all(migrationPromises);
                    console.log("æ•°æ®è¿ç§»æˆåŠŸå®Œæˆã€‚");
                    saveState();
                } catch(error) {
                    console.error("æ•°æ®è¿ç§»è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
                }
            }
            
            // START: MODIFIED initialization for styles
            applyTheme(state.settings.theme);
            applyCustomStyles();
            // END: MODIFIED initialization

            applyNicknameVisibility();
            initEventHandlers(); 
            renderAll();
        };

        init();
    });
    </script>

<!-- Auto-resize message iframes to real content -->
<script id="unlimit-iframe-resize">
(function(){
  function fitIframe(iframe){
    if(!iframe) return;
    iframe.onload = function(){
      try {
        var doc = iframe.contentDocument || iframe.contentWindow.document;
        if(!doc) return;
        var docEl = doc.documentElement;
        var body = doc.body;
        var contentWidth  = Math.max(docEl.scrollWidth,  body ? body.scrollWidth  : 0, docEl.offsetWidth,  body ? body.offsetWidth  : 0);
        var contentHeight = Math.max(docEl.scrollHeight, body ? body.scrollHeight : 0, docEl.offsetHeight, body ? body.offsetHeight : 0);

        iframe.style.transform = '';
        iframe.style.width  = contentWidth + 'px';
        iframe.style.height = contentHeight + 'px';

        var renderContainer = iframe.parentElement;
        if (renderContainer){
          renderContainer.style.width  = 'auto';
          renderContainer.style.height = 'auto';
        }

        var messageDiv = iframe.closest && iframe.closest('.message');
        if (messageDiv){ messageDiv.classList.add('message-render-expand'); }
      } catch(e){
        console.error("Error adjusting iframe size:", e);
        iframe.style.width  = '100%';
        iframe.style.height = 'auto';
      }
    };
  }

  function applyAll(){
    var iframes = document.querySelectorAll('.message iframe');
    iframes.forEach(fitIframe);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyAll);
  } else {
    applyAll();
  }

  // Watch for newly added iframes (e.g., whenæ–°æ¶ˆæ¯è¿›æ¥)
  var mo = new MutationObserver(function(mutations){
    for (var m of mutations){
      m.addedNodes && m.addedNodes.forEach(function(node){
        if (node && node.querySelectorAll){
          node.querySelectorAll('iframe').forEach(fitIframe);
        } else if (node && node.tagName === 'IFRAME'){
          fitIframe(node);
        }
      });
    }
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });
})();
</script>

<!-- Mobile auto-scale for render iframes -->
<script>
(function () {
  function attachFit(iframe) {
    if (!iframe) return;
    iframe.addEventListener('load', function () {
      try {
        const renderContainer = iframe.parentElement;
        const messageDiv = renderContainer ? renderContainer.closest && renderContainer.closest('.message') : null;

        const fit = () => {
          const doc = iframe.contentDocument || iframe.contentWindow.document;
          if (!doc) return;
          const docEl = doc.documentElement;
          const body = doc.body || docEl;

          const contentWidth  = Math.max(docEl.scrollWidth,  body.scrollWidth,  docEl.offsetWidth,  body.offsetWidth);
          const contentHeight = Math.max(docEl.scrollHeight, body.scrollHeight, docEl.offsetHeight, body.offsetHeight);

          const chat = document.getElementById('chat-container');
          const chatW = chat ? chat.clientWidth : document.documentElement.clientWidth;
          const maxW  = Math.max(200, chatW - 80); // ç•™å‡ºå¤´åƒ/è¾¹è·
          const pad   = 10;

          messageDiv && messageDiv.classList && messageDiv.classList.remove('message-render-expand');
          iframe.style.transform = '';
          if (renderContainer) {
            renderContainer.style.width = 'auto';
            renderContainer.style.height = 'auto';
          }

          const scale = Math.min(1, maxW / contentWidth);

          iframe.style.width  = contentWidth + 'px';
          iframe.style.height = contentHeight + 'px';
          iframe.style.transformOrigin = 'top left';
          iframe.style.transform = 'scale(' + scale + ')';

          if (renderContainer) {
            renderContainer.style.width  = Math.min(contentWidth * scale, maxW) + 'px';
            renderContainer.style.height = Math.ceil(contentHeight * scale) + pad + 'px';
          }

          if (scale === 1 && messageDiv && messageDiv.classList) {
            messageDiv.classList.add('message-render-expand');
          }
        };

        setTimeout(fit, 120);
        window.addEventListener('resize', fit);
        window.addEventListener('orientationchange', fit);

        let tick = 0;
        const timer = setInterval(() => {
          fit();
          tick++;
          if (tick > 10) clearInterval(timer);
        }, 250);
      } catch (e) {
        console.error('Error adjusting iframe size:', e);
        iframe.style.width = '100%';
        iframe.style.height = '240px';
      }
    }, { once: false });
  }

  // ç»‘å®šç°æœ‰
  document.querySelectorAll('.render-container iframe').forEach(attachFit);

  // ç»‘å®šåŠ¨æ€æ–°å¢
  const mo = new MutationObserver((muts) => {
    muts.forEach(m => {
      (m.addedNodes || []).forEach(node => {
        if (node.nodeType === 1) {
          node.querySelectorAll && node.querySelectorAll('.render-container iframe').forEach(attachFit);
          if (node.matches && node.matches('.render-container iframe')) attachFit(node);
        }
      });
    });
  });
  mo.observe(document.documentElement, { childList: true, subtree: true });
})();
</script>

<!-- storage_patch (inlined) - moves large buckets to IndexedDB to avoid quota -->
<script>

/**
 * storage_patch.js
 * Patch for index6.6.html to move large data (presets/characterCards/globalWorldBooks/conversations)
 * out of localStorage into IndexedDB to avoid "The quota has been exceeded" and allow importing many items.
 *
 * Usage: include this file AFTER the main script in index6.6.html, right before </body>:
 *
 * This patch overrides saveState() and loadState() at runtime, and performs one-time migration.
 */
(function () {
  if (!window.indexedDB) {
    console.warn('[StoragePatch] IndexedDB is not supported in this browser. Patch skipped.');
    return;
  }

  const DB_NAME = 'ai-chat-app-db';
  const DB_VERSION = 1;
  const STORE_META = 'meta';
  const STORE_BUCKETS = ['presets', 'characterCards', 'globalWorldBooks', 'conversations'];

  let _dbPromise = null;
  function openDB() {
    if (_dbPromise) return _dbPromise;
    _dbPromise = new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_META)) {
          db.createObjectStore(STORE_META, { keyPath: 'id' });
        }
        for (const store of STORE_BUCKETS) {
          if (!db.objectStoreNames.contains(store)) {
            db.createObjectStore(store, { keyPath: 'id' });
          }
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
    return _dbPromise;
  }

  async function idbPut(storeName, record) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, 'readwrite');
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
      tx.objectStore(storeName).put(record);
    });
  }

  async function idbGet(storeName, id) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, 'readonly');
      tx.onerror = () => reject(tx.error);
      const req = tx.objectStore(storeName).get(id);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbClear(storeName) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(storeName, 'readwrite');
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
      tx.objectStore(storeName).clear();
    });
  }

  function shallowCloneMetaFromState(state) {
    // copy everything except the heavy buckets
    const {
      providers, currentConversationId, currentProviderIndex, currentModel,
      settings, userProfile, modelProfiles,
      // exclude heavy arrays
      presets, conversations, characterCards, globalWorldBooks,
      ...rest
    } = state;
    return {
      id: 'meta',
      providers,
      currentConversationId,
      currentProviderIndex,
      currentModel,
      settings,
      userProfile,
      modelProfiles,
      ...rest
    };
  }

  async function writeBucketsToIDB(state) {
    // Store entire arrays as one record per bucket for simplicity
    await idbPut('presets', { id: 'all', value: state.presets || [] });
    await idbPut('characterCards', { id: 'all', value: state.characterCards || [] });
    await idbPut('globalWorldBooks', { id: 'all', value: state.globalWorldBooks || [] });
    await idbPut('conversations', { id: 'all', value: state.conversations || [] });
  }

  async function readBucketsFromIDB() {
    const [presets, characterCards, globalWorldBooks, conversations] = await Promise.all([
      idbGet('presets', 'all'),
      idbGet('characterCards', 'all'),
      idbGet('globalWorldBooks', 'all'),
      idbGet('conversations', 'all'),
    ]);
    return {
      presets: presets?.value || [],
      characterCards: characterCards?.value || [],
      globalWorldBooks: globalWorldBooks?.value || [],
      conversations: conversations?.value || [],
    };
  }

  async function migrateFromLocalStorage() {
    try {
      const raw = localStorage.getItem('ai-chat-app-data');
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      const toWrite = {
        presets: parsed.presets || [],
        characterCards: parsed.characterCards || [],
        globalWorldBooks: parsed.globalWorldBooks || [],
        conversations: parsed.conversations || [],
      };
      await writeBucketsToIDB(toWrite);

      // Keep only light-weight meta in localStorage
      const metaOnly = {
        providers: parsed.providers || [],
        currentConversationId: parsed.currentConversationId ?? null,
        currentProviderIndex: parsed.currentProviderIndex ?? 0,
        currentModel: parsed.currentModel || '',
        settings: parsed.settings || {},
        userProfile: parsed.userProfile || { name: '', avatar: '', description: '' },
        modelProfiles: parsed.modelProfiles || {},
      };
      localStorage.setItem('ai-chat-app-data', JSON.stringify(metaOnly));
      console.info('[StoragePatch] Migration completed. Heavy data moved into IndexedDB.');
      return true;
    } catch (e) {
      console.warn('[StoragePatch] Migration skipped or failed:', e);
      return false;
    }
  }

  // Hook into global saveState/loadState
  const patchReady = () => typeof window.state !== 'undefined';

  const installPatch = () => {
    if (!patchReady()) return false;
    const originalSaveState = window.saveState;
    const originalLoadState = window.loadState;

    // Replace saveState
    window.saveState = async function patchedSaveState() {
      try {
        if (!window.state) return;
        // 1) Save buckets to IDB
        await writeBucketsToIDB(window.state);
        // 2) Save meta to localStorage (tiny)
        const meta = shallowCloneMetaFromState(window.state);
        localStorage.setItem('ai-chat-app-data', JSON.stringify(meta));
      } catch (e) {
        console.error('[StoragePatch] saveState failed:', e);
        // Fallback: try original (may hit quota)
        try { originalSaveState && originalSaveState(); } catch (ee) {}
      }
    };

    // Replace loadState
    window.loadState = async function patchedLoadState() {
      try {
        // First, run original to initialize any required structures
        if (originalLoadState) originalLoadState();
      } catch (e) {
        console.warn('[StoragePatch] Original loadState failed (this is okay):', e);
      }

      // Run one-time migration if old heavy data is still in localStorage
      await migrateFromLocalStorage();

      // Merge meta from localStorage with buckets from IDB into window.state
      const metaRaw = localStorage.getItem('ai-chat-app-data');
      let meta = {};
      try { meta = metaRaw ? JSON.parse(metaRaw) : {}; } catch { meta = {}; }

      const buckets = await readBucketsFromIDB();
      // Ensure window.state exists
      window.state = window.state || {};
      Object.assign(window.state, buckets, meta);

      // If presets list empty, ensure there's at least a default
      if (!Array.isArray(window.state.presets) || window.state.presets.length === 0) {
        window.state.presets = [ (window.getDefaultPreset ? window.getDefaultPreset() : { id: 'default-'+Date.now(), name: 'é»˜è®¤é¢„è®¾', prompts: [], regexes: [] }) ];
        window.state.currentPresetId = window.state.presets[0].id;
        await window.saveState();
      }

      console.info('[StoragePatch] loadState complete (IndexedDB-backed).');
    };

    // Export a tiny API for debugging
    window.__storagePatch = {
      openDB,
      readBucketsFromIDB,
      writeBucketsToIDB,
      migrateFromLocalStorage
    };

    return true;
  };

  // Try to install immediately, otherwise after DOM ready
  if (!installPatch()) {
    document.addEventListener('DOMContentLoaded', () => installPatch());
  }
})();

</script>
</body>
</html>